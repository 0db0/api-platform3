# Simpler Validator

We're down to *one last failing test*. Apparently we can *steal* treasures by having a treasure owned by one user, patching a *different* user, and sending that treasure *on* this property. This should give us a `422` status code. We're currently getting a *200* status code, but that's okay. We already fixed this in the previous tutorial. *Now* we just need to reactivate and *adapt* that validator.

In `UserApi.php`, above the `$dragonTreasures` property, we can get rid of this `#[ApiProperty]` and say `#[TreasuresAllowedOwnerChange]`. Previously, we put this above that same `$dragonTreasures` property. Inside of our user `$entity`, it would loop over each `DragonTreasure`, use Doctrine's `$unitOfWork` to get the `$originalOwnerId`, and *then* check to see if the `$newOwnerAid` is different from the `$originalOwnerId`. If it *was*, it would build a violation.

First things first: This is *not* going to be above a Doctrine `Collection` field anymore; It's just going to be an array. And we'll *also* add `dd($value)`. To help clear things up, let's put a `dump()` at the top of the test that says `Real owner is` with `.$otherUser->getId()`. That'll help us track if it's stolen.

Okay, let's run *just* this test. And... perfect! The "Real owner" is supposed to be `2`, and apparently, when we dump our array, we can see the one `DragonTreasureApi` object. And check this out! The `owner` is still `2`. So by the time we get into this validator here, we're passed the array of `DragonTreasureApi` objects, and it looks like the `owner` is just fine. It hasn't changed. But *of course* everything is fine. So far in this test, we've just told the serializer to load this specific treasure from the database that will be *owned* by this user, and then *set* it onto our `UserApi`. This object *hasn't* actually changed owners yet. The *problematic* part comes later when we allow our state processor, and really, our `UserApiToEntityMapper`, to map the new `dragonTreasures` that are on *that* user onto our user `$entity`. Without digging into the topic *too much*, this would actually cause the owner of the `DragonTreasure` to be changed. We talked more about this in a previous tutorial, but this basically has to do with the fact that, for example, when `addDragonTreasure()` is finally called on user, it's actually going to call `setOwner()` on the `$treasure` and change it then. Long story short, the problem with stealing treasure is going to come later, and we need to stop it *before* saving in this validator. But right now, everything in this validator *seems* to be fine.

But what if I told you I can *prove* that this isn't going to work? Check this out! We're going to *temporarily* short circuit this validator by putting a `return` statement here. And in `UserResourceTest.php`, we're just going to `->det('/api/users/'.$otherUser->getId())`, adding `->dump()` at the end. When we run the test now... whoa... `dragonTreasures` is *empty* for that user. It *shouldn't* be empty. This `$otherUser` should *own* this `$dragonTreasure`, so this treasure was *stolen*.

To sort out this mess in our validator, we need to know *two* things. First, we need to know what the *original* owner for each of these `dragonTreasures` was. A second ago, we saw that each of the `DragonTreasureApi` objects here still have their original owner set, so that's easy to find. The *second* thing we need to know is which *user* we're trying to move these treasures to, and we don't have that info yet. To get that, we'll need to change the target of the validator from this specific property, where all we have access to are the `DragonTreasure` objects, up onto the class. That will give us access to this `UserApi` object as well as the `$dragonTreasures`.

Check this out! We're going to move this up above the class. *Then*, to make that work, we need to open that class and get rid of the annotation stuff (since we're not using annotations anymore). And now we'll change this from `TARGET_PROPERTY` and `TARGET_METHOD` to `TARGET_CLASS`. For some reason, my editor adds an extra `\` there, so we can delete that. We *also* need to override a method here from the `parent`. I'm not sure why we have to specify the target in both places, but we do. And finally, we're going to `return self::CLASS_CONSTRAINT`. This is another way the validator system figures out that this validator can be applied to a class. Right here, we'll also add a return type - `string|array` - which is *optional*, but we might get a deprecation notice if we don't do that.

Now, over in our validator, let's `dd($value)`, rerun the test, and... perfect! We can see that it's dumping the *entire* `UserApi` object with and ID of `1`. Good stuff! Then, the `dragonTreasures` property holds that single `dragonTreasure`, but down here, you can see who its original owner was. This makes us *dangerous*. We can just check to see if the *new* owner is different from the *original* owner, and if it *is*, we have a problem. This makes life *a lot* easier.

Back over here, let's add an `assert()` that `$value` is an `instanceof UserApi`. Then, we're going to `foreach` over `$value->dragonTreasures as $dragonTreasureApi`. And we don't need any of this `$unitOfWork` stuff anymore, so we can delete that. Then we can say `$originalOwnerId = $dragonTreasureApi->owner->id`. We saw before that that's still set to the original ID. And then the `$newOwnerId` is going to be `$value->id`. That's it! If you want to code defensively, you can add a `?` here, just in case there *isn't* an owner for some reason. There *should be*, but it just depends on how your API is set up. The logic down here is still okay, so we'll leave it alone. Basically, if we *don't* have the `$originalOwnerId` or the `$originalOwnerId` equals `$newOwnerId`, everything is cool. *Else*, we need to build this violation down here. We can remove this `$unitOfWork` line here as well, those `use` statements up here, this `EntityManagerInterface` constructor... and now we have a *really* boring custom validation constraint. That's thanks to the new system having our API class *separate* from our entity classes. Let's run that test again, and... green! We *got it*!

Okay, let's remove this `->dump()` from the top... and we're going to *celebrate* by running the *whole* test suite:

```terminal
symfony php bin/phpunit
```

And... *all green*! We have *completely* rebuilt our system using DTOs! Woohoo!

All right, friends! It took a little bit of work to get that all set up, but that's the whole point of DTOs. There's more groundwork in the beginning in exchange for more flexibility and clarity later on, *especially* if you're building a really robust API that you don't want to change. That concludes part *three* of our API Platform tutorial! As always, if you need help or have questions, we're here for you down in the comments. Thanks for following along, and we'll see you next time!
