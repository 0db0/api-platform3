WEBVTT

00:00:01.076 --> 00:00:06.906 align:middle
En un giro heroico de valentía, hemos decidido
realizar todas las pruebas del tesoro del dragón: Y...

00:00:06.906 --> 00:00:12.876 align:middle
tenemos tres fallos, incluido uno de
testAdminCanPatchToEditTreasure en la línea 200...

00:00:12.976 --> 00:00:16.346 align:middle
que dice
->assertJsonMatched('isPublished', true).

00:00:16.906 --> 00:00:18.336 align:middle
Eso falla porque...

00:00:18.556 --> 00:00:22.386 align:middle
¡no tenemos ningún campo isPublished
en nuestro DragonTreasureApi!

00:00:22.696 --> 00:00:24.776 align:middle
Eso es porque se trata de un campo interesante.

00:00:25.106 --> 00:00:29.616 align:middle
Antes, este campo sólo lo podían leer los
usuarios administradores o el propietario.

00:00:29.966 --> 00:00:32.556 align:middle
Volvamos a añadir este campo y
mantengamos ese comportamiento.

00:00:33.396 --> 00:00:35.866 align:middle
Digamos public bool $isPublished = false.

00:00:37.566 --> 00:00:40.496 align:middle
Entonces... entra en el
mapeador para rellenarlo.

00:00:41.676 --> 00:00:48.026 align:middle
Aquí abajo, deshazte de TODO y di
$entity->setIsPublished($dto->isPublished).

00:00:48.966 --> 00:00:55.116 align:middle
Así, si cambiamos isPublished en la llamada a la
API, el nuevo valor se sincronizará con la entidad.

00:00:55.786 --> 00:00:56.946 align:middle
En el otro lado...

00:00:57.096 --> 00:00:58.206 align:middle
no importa dónde...

00:00:58.556 --> 00:01:02.686 align:middle
digamos $dto->isPublished =
$entity->getIsPublished().

00:01:03.256 --> 00:01:05.846 align:middle
¡Genial! Aún no tenemos seguridad...

00:01:06.156 --> 00:01:11.646 align:middle
así que cuando ejecutamos las pruebas: Unas
cuantas pasan, pero la original sigue fallando -

00:01:12.046 --> 00:01:16.876 align:middle
testGetCollectionOfTreasures - porque
no espera que el isPublished esté ahí.

00:01:17.776 --> 00:01:21.856 align:middle
Fíjate: ésta es la primera
prueba, y en la parte inferior,

00:01:22.456 --> 00:01:25.926 align:middle
hemos afirmado que éstas son las
propiedades exactas que deberíamos tener

00:01:26.066 --> 00:01:28.896 align:middle
si obtenemos tesoros como usuario anónimo.

00:01:29.456 --> 00:01:36.876 align:middle
Así que, como no somos el propietario ni un administrador,
no deberíamos ver isPublished ¿Cómo podemos hacer eso?

00:01:37.696 --> 00:01:40.676 align:middle
Antes hemos trabajado con
DragonTreasureApiVoter.

00:01:41.766 --> 00:01:43.676 align:middle
Cuando lo llamamos con el
atributo EDIT, comprueba

00:01:44.006 --> 00:01:49.036 align:middle
si somos administradores y,
si lo somos, nos da acceso.

00:01:50.576 --> 00:01:53.266 align:middle
También comprueba si somos el propietario.

00:01:53.886 --> 00:01:57.156 align:middle
Ésta es exactamente la lógica que
queremos utilizar para determinar

00:01:57.186 --> 00:02:00.026 align:middle
si el campo isPublished debe serializarse.

00:02:00.476 --> 00:02:01.526 align:middle
Así que... ¡vamos a utilizarla!

00:02:02.236 --> 00:02:08.276 align:middle
Encima de esta propiedad, digamos #[ApiProperty(security:
'is_granted("EDIT", object)')]. Si

00:02:08.816 --> 00:02:12.206 align:middle
quieres, puedes cambiar
este atributo por otra cosa

00:02:12.476 --> 00:02:14.286 align:middle
-como OWNER - si te resulta más claro.

00:02:14.736 --> 00:02:16.296 align:middle
EDIT suena un poco raro aquí...

00:02:16.556 --> 00:02:20.396 align:middle
ya que sólo estamos decidiendo si debemos
incluir este campo en la respuesta...

00:02:20.476 --> 00:02:21.426 align:middle
no "editarlo"...

00:02:21.506 --> 00:02:22.456 align:middle
pero depende de ti.

00:02:23.326 --> 00:02:26.346 align:middle
Y lo que es más importante,
veamos si esto funciona.

00:02:26.916 --> 00:02:31.606 align:middle
Ejecuta las pruebas: ¡Se ha
solucionado nuestra primera prueba!

00:02:31.946 --> 00:02:34.476 align:middle
El campo isPublished ya no se muestra.

00:02:34.726 --> 00:02:38.966 align:middle
Pero, curiosamente, hemos
hecho fallar otra prueba.

00:02:39.326 --> 00:02:40.196 align:middle
¡A la porra!

00:02:40.626 --> 00:02:44.916 align:middle
Ahora es testPublishTreasure
- falla en la línea 244.

00:02:44.916 --> 00:02:48.146 align:middle
Vamos a buscarlo.

00:02:48.146 --> 00:02:52.786 align:middle
Vale, como su nombre indica, estamos
probando si podemos publicar este tesoro.

00:02:53.236 --> 00:02:57.936 align:middle
Creamos un tesoro que es 'isPublished' =>
false , iniciamos sesión como su propietario

00:02:58.326 --> 00:03:02.216 align:middle
y, a continuación, enviamos una petición a
patch() para establecer isPublished en true.

00:03:02.316 --> 00:03:07.806 align:middle
Por último, afirmamos que el JSON de la
respuesta tiene isPublished verdadero.

00:03:08.426 --> 00:03:10.066 align:middle
Y eso es lo que falla.

00:03:10.706 --> 00:03:14.766 align:middle
¿Por qué? Me llevó un poco de
depuración desentrañar este misterio.

00:03:15.126 --> 00:03:21.276 align:middle
El problema es que, cuando se deserializa
el JSON, isPublished no es escribible.

00:03:21.586 --> 00:03:26.836 align:middle
La expresión security se llama tanto
al serializar como al deserializar:

00:03:27.226 --> 00:03:31.066 align:middle
al tomar el JSON de la petición
y al actualizar el objeto.

00:03:31.536 --> 00:03:37.616 align:middle
Por alguna razón, durante la deserialización,
¡nuestra expresión security devuelve false!

00:03:38.146 --> 00:03:39.136 align:middle
La razón es...

00:03:39.206 --> 00:03:43.246 align:middle
posiblemente un error: Tengo una
incidencia abierta en API Platform.

00:03:43.886 --> 00:03:45.296 align:middle
Cuando realizas una petición a patch(),

00:03:45.716 --> 00:03:49.186 align:middle
nuestro proveedor de datos carga primero
el objeto desde la base de datos.

00:03:49.616 --> 00:03:56.466 align:middle
A pesar de ello, cuando se llama a la expresión
durante la deserialización, object siempre es nulo.

00:03:56.796 --> 00:04:03.606 align:middle
Y como nuestro votante sólo admite si object
es un DragonTreasureApi, éste devuelve false.

00:04:04.416 --> 00:04:09.936 align:middle
En última instancia, ningún votante admite
esto, y cuando ocurre, se deniega el acceso.

00:04:10.606 --> 00:04:13.636 align:middle
El resultado final es que
isPublished no es escribible.

00:04:14.386 --> 00:04:17.426 align:middle
La solución es un poco
extraña, pero quédate conmigo.

00:04:17.776 --> 00:04:20.606 align:middle
Básicamente, vamos a permitir
el acceso a este campo

00:04:20.766 --> 00:04:26.296 align:middle
si object === null o
is_granted("EDIT", object).

00:04:26.946 --> 00:04:27.686 align:middle
Piensa en esto.

00:04:28.076 --> 00:04:32.476 align:middle
Si estamos leyendo un DragonTreasure,
entonces object nunca es null.

00:04:32.856 --> 00:04:36.606 align:middle
Siempre tendremos un objeto, por lo
que siempre se llamará al votante.

00:04:37.176 --> 00:04:44.096 align:middle
Este object === null sólo ocurrirá durante
la deserialización: cuando estemos comprobando

00:04:44.096 --> 00:04:46.396 align:middle
si podemos escribir este campo.

00:04:47.066 --> 00:04:50.916 align:middle
Esto hace que el campo sea siempre escribible.

00:04:51.536 --> 00:04:54.036 align:middle
Esto parece un problema, pero no lo es,

00:04:54.286 --> 00:04:57.876 align:middle
porque ya tenemos security aquí
arriba en Post() y Patch().

00:04:57.916 --> 00:05:01.596 align:middle
En Patch, sólo el propietario
puede editar este objeto.

00:05:02.106 --> 00:05:07.626 align:middle
Así que, una vez superada la seguridad de
Patch, ya sabemos que puede editar este objeto.

00:05:08.156 --> 00:05:11.366 align:middle
Así que, aquí abajo, está bien que
siempre podamos editar este campo.

00:05:12.146 --> 00:05:15.696 align:middle
Si esto te parece demasiado
raro, otra estrategia es

00:05:15.696 --> 00:05:19.336 align:middle
dejar la seguridad API fuera
del campo por completo.

00:05:19.816 --> 00:05:24.906 align:middle
Entonces, utilizaríamos el mapeador para manejar
la configuración condicional del campo isPublished.

00:05:25.466 --> 00:05:28.606 align:middle
Podríamos poner aquí una lógica
de seguridad que dijera básicamente

00:05:28.956 --> 00:05:33.236 align:middle
Establece el campo isPublished en
el DTO sólo si eres el propietario.

00:05:33.736 --> 00:05:37.116 align:middle
De lo contrario, deja
isPublished nulo por defecto.

00:05:37.216 --> 00:05:42.256 align:middle
Es bueno recordar que tenemos el control total
de los datos a través de nuestros mapeadores.

00:05:43.186 --> 00:05:46.396 align:middle
Bien, volvamos atrás y añadamos de
nuevo nuestra expresión de seguridad.

00:05:47.356 --> 00:05:49.946 align:middle
Y vuelve también al mapeador:

00:05:49.946 --> 00:05:53.566 align:middle
Acabo de darme cuenta de que también
queremos mantener ese código isPublished...

00:05:53.716 --> 00:05:55.466 align:middle
sólo que no en la declaración if.

00:05:56.686 --> 00:06:00.156 align:middle
Muy bien, ahora vuelve a
ejecutar todas las pruebas.

00:06:00.736 --> 00:06:02.256 align:middle
Y... ¡ooh!

00:06:02.256 --> 00:06:07.066 align:middle
¡Tan cerca! Sólo nos queda un
fallo en testPublishTreasure.

00:06:07.796 --> 00:06:12.616 align:middle
Esto prueba que, cuando se publica un
tesoro, enviamos una notificación.

00:06:13.286 --> 00:06:16.336 align:middle
Veamos cómo podemos resolverlo
en nuestro nuevo sistema
