WEBVTT

00:00:01.116 --> 00:00:06.586 align:middle
Estamos muy cerca de reimplementar completamente
nuestra API utilizando estas clases personalizadas.

00:00:07.056 --> 00:00:07.996 align:middle
¡Qué emoción!

00:00:08.496 --> 00:00:10.436 align:middle
Vamos a ejecutar todas las pruebas
para ver en qué punto estamos.

00:00:10.946 --> 00:00:16.106 align:middle
symfony php bin/phpunit Y...

00:00:16.286 --> 00:00:18.926 align:middle
todo pasa excepto una.

00:00:19.636 --> 00:00:24.306 align:middle
Esta prueba problemática es
UserResourceTest::testTreasuresCannotBeStolen.

00:00:25.156 --> 00:00:25.996 align:middle
¡Vamos a comprobarlo!

00:00:26.676 --> 00:00:32.046 align:middle
Abre tests/Functional/UserResourceTest.php
y busca testTreasuresCannotBeStolen().

00:00:32.386 --> 00:00:32.946 align:middle
Aquí lo tienes.

00:00:33.516 --> 00:00:35.136 align:middle
Leamos la historia.

00:00:35.736 --> 00:00:39.766 align:middle
Actualizamos un usuario e intentamos
cambiar su propiedad dragonTreasures

00:00:39.866 --> 00:00:43.156 align:middle
para que contenga un tesoro
propiedad de otra persona. La

00:00:43.646 --> 00:00:46.046 align:middle
prueba busca un código de estado 422

00:00:46.506 --> 00:00:51.496 align:middle
-porque queremos evitar el robo de
tesoros-, pero la prueba falla con un 200.

00:00:52.006 --> 00:00:56.556 align:middle
Pero aparte de todo el tema del robo,
ésta es la primera prueba que hemos visto

00:00:56.556 --> 00:01:00.116 align:middle
que escribe en un campo de
relación de colección.

00:01:00.416 --> 00:01:03.646 align:middle
Y ése es un tema interesante por sí solo.

00:01:03.646 --> 00:01:06.916 align:middle
En primer lugar, si puedes, te recomiendo que

00:01:06.916 --> 00:01:11.366 align:middle
no permitas que los campos de relación
de colección como éste sean escribibles.

00:01:11.776 --> 00:01:13.916 align:middle
Es decir, puedes hacerlo...

00:01:13.976 --> 00:01:15.426 align:middle
pero añade complejidad. Por

00:01:15.956 --> 00:01:18.196 align:middle
ejemplo, como muestra esta prueba, tenemos

00:01:18.406 --> 00:01:23.106 align:middle
que preocuparnos de cómo establecer la
propiedad dragonTreasures cambia el propietario

00:01:23.106 --> 00:01:23.946 align:middle
en ese tesoro.

00:01:23.986 --> 00:01:29.196 align:middle
Y ya existe otra forma de hacerlo: hacer
una petición a patch() a este tesoro y...

00:01:29.196 --> 00:01:30.476 align:middle
cambia la propiedad owner.

00:01:30.666 --> 00:01:35.796 align:middle
¡Sencillo! Pero, si aún quieres permitir
que tu relación de colección sea escribible

00:01:35.796 --> 00:01:39.426 align:middle
en tu sistema DTO, bien,
aquí tienes cómo hacerlo.

00:01:39.426 --> 00:01:41.186 align:middle
Es broma, no está tan mal.

00:01:41.676 --> 00:01:43.446 align:middle
Empieza por duplicar esta prueba.

00:01:46.426 --> 00:01:49.076 align:middle
Cámbiale el nombre a
testTreasuresCanBeRemoved.

00:01:49.636 --> 00:01:55.346 align:middle
Lo he escrito mal: el mío dice cannot, que
es lo contrario de lo que quiero probar,

00:01:55.566 --> 00:01:57.406 align:middle
así que asegúrate de que lo
escribes bien en tu código.

00:01:58.226 --> 00:01:59.716 align:middle
Ahora podemos arreglarlo un poco.

00:02:00.266 --> 00:02:02.686 align:middle
Haz que el primer $dragonTreasure
pertenezca a $user.

00:02:03.136 --> 00:02:09.416 align:middle
Luego crea un segundo $dragonTreasure también propiedad
de $user, pero no necesitaremos una variable para él...

00:02:09.416 --> 00:02:09.746 align:middle
ya lo verás.

00:02:09.906 --> 00:02:16.586 align:middle
Por último, añade un tercer $dragonTreasure llamado
$dragonTreasure3 que sea propiedad de $otherUser.

00:02:18.046 --> 00:02:22.706 align:middle
Así que tenemos tres dragonTreasures, dos
propiedad de $user, y uno de $otherUser.

00:02:23.216 --> 00:02:25.876 align:middle
Aquí abajo, parcheamos para modificar $user.

00:02:26.506 --> 00:02:31.036 align:middle
Elimina username -no nos importa-
y envía dos dragonTreasures:

00:02:31.366 --> 00:02:37.746 align:middle
el primero y el tercero: /api/treasures/
$dragonTreasure3->getId() .

00:02:37.746 --> 00:02:40.726 align:middle
Vamos a comprobar dos cosas.

00:02:40.806 --> 00:02:44.656 align:middle
En primer lugar, que se elimine
el segundo tesoro de este usuario.

00:02:44.656 --> 00:02:48.526 align:middle
Piénsalo: $user empezó
con estos dos tesoros...

00:02:48.526 --> 00:02:53.586 align:middle
y el hecho de que no se envíe el IRI
de este segundo tesoro significa que

00:02:53.586 --> 00:02:56.106 align:middle
queremos que se elim ine de $user.

00:02:56.926 --> 00:03:03.376 align:middle
En segundo lugar, he añadido $dragonTreasure3 temporalmente
para demostrar que los tesoros se pueden robar.

00:03:03.886 --> 00:03:08.086 align:middle
Actualmente pertenece a $otherUser,
pero lo pasamos a dragonTreasures...

00:03:08.586 --> 00:03:10.476 align:middle
y vamos a comprobar que el propietario

00:03:10.476 --> 00:03:14.606 align:middle
de $dragonTreasure3 cambia
de $otherUser a $user.

00:03:15.086 --> 00:03:20.926 align:middle
No es el comportamiento final que queremos, pero nos
ayudará a que funcione la escritura de relaciones.

00:03:21.306 --> 00:03:23.906 align:middle
Luego nos preocuparemos de evitarlo.

00:03:25.056 --> 00:03:31.896 align:middle
Aquí abajo, ->assertStatus(200) amplía
la prueba diciendo ->get('/api/users/' .

00:03:31.896 --> 00:03:35.836 align:middle
$user->getId()) y ->dump().

00:03:35.966 --> 00:03:39.856 align:middle
Quiero ver qué aspecto tiene el usuario después
de la actualización. Por último, afirma que

00:03:39.856 --> 00:03:44.146 align:middle
el length del campo dragonTreasures

00:03:45.256 --> 00:03:50.586 align:middle
-necesito comillas al respecto-
es 2, para los tesoros 1 y 3.

00:03:52.446 --> 00:03:57.156 align:middle
Luego afirma que dragonTreasures[0]
es igual a '/api/treasures/'.,

00:03:57.206 --> 00:04:00.396 align:middle
seguido de $dragonTreasure->getId().

00:04:01.616 --> 00:04:07.146 align:middle
Cópialo, pégalo y afirma que
la clave 1 es $dragonTreasure3.

00:04:09.316 --> 00:04:14.336 align:middle
¡Estupendo! Esa prueba ha costado
trabajo, pero será superútil.

00:04:14.916 --> 00:04:17.076 align:middle
Vamos... ¡a ejecutarla y a ver qué pasa!

00:04:17.606 --> 00:04:23.106 align:middle
Copia el nombre del método y, en tu
terminal, ejecútalo: symfony php bin/phpunit

00:04:23.106 --> 00:04:29.666 align:middle
--filter=testTreasuresCanBeRemoved
Y con "no se puede eliminar",

00:04:29.666 --> 00:04:32.356 align:middle
quiero decir, por supuesto,
que se puede eliminar.

00:04:33.176 --> 00:04:36.026 align:middle
Menuda locura de copiar y pegar.

00:04:37.026 --> 00:04:37.496 align:middle
Ya está.

00:04:38.526 --> 00:04:42.196 align:middle
Y... falla, en la línea 81.

00:04:42.926 --> 00:04:45.706 align:middle
Esto significa que la petición
se ha realizado correctamente...

00:04:46.006 --> 00:04:49.426 align:middle
pero los dragonTreasures siguen
siendo los dos originales:

00:04:49.506 --> 00:04:56.416 align:middle
/api/treasures/2 en lugar de /api/treasures/3.

00:04:57.026 --> 00:04:59.326 align:middle
No se han realizado cambios en los tesoros.

00:04:59.856 --> 00:05:04.626 align:middle
¿Por qué? Averigüémoslo a continuación y
aprovechemos el componente accesor de propiedades

00:05:04.866 --> 00:05:07.356 align:middle
para asegurarnos de que los
cambios se guardan correctamente.
