WEBVTT

00:00:01.056 --> 00:00:04.836 align:middle
Sólo nos queda un fallo de prueba:
está en testPublishTreasure.

00:00:05.336 --> 00:00:06.516 align:middle
Vamos a comprobarlo.

00:00:07.586 --> 00:00:12.876 align:middle
Vale, esto prueba que se crea una notificación
en la base de datos cuando el estado

00:00:12.876 --> 00:00:17.916 align:middle
de un tesoro cambia de 'isPublished'
=> false a 'isPublished' => true.

00:00:17.916 --> 00:00:21.836 align:middle
Antes, implementábamos esto mediante
un procesador de estado personalizado.

00:00:22.286 --> 00:00:25.376 align:middle
Pero ahora, ¡podríamos ponerlo
en nuestra clase mapeadora!

00:00:25.906 --> 00:00:29.346 align:middle
En DragonTreasureApiToEntityMapper,
podríamos comprobar

00:00:29.346 --> 00:00:35.266 align:middle
si la entidad era 'isPublished' => false y
ahora está cambiando a 'isPublished' => true.

00:00:35.956 --> 00:00:39.716 align:middle
Si es así, crea una notificación allí mismo.

00:00:40.366 --> 00:00:42.986 align:middle
Si esto te parece bien, ¡adelante!

00:00:43.356 --> 00:00:47.796 align:middle
Sin embargo, para mí, poner la lógica
aquí no me parece del todo bien...

00:00:48.136 --> 00:00:51.956 align:middle
porque se trata de un "mapeador de
datos " , por lo que huele un poco raro

00:00:51.956 --> 00:00:54.796 align:middle
hacer algo más allá de
simplemente mapear los datos.

00:00:55.526 --> 00:01:01.066 align:middle
Así que volvamos a nuestra solución
original: crear un procesador de estados.

00:01:01.826 --> 00:01:06.376 align:middle
En tu terminal, ejecuta: php
bin/console make:state-processor

00:01:06.376 --> 00:01:08.496 align:middle
Llámalo DragonTreasureStateProcessor.

00:01:09.396 --> 00:01:13.536 align:middle
Nuestro objetivo debería resultarte familiar:
añadiremos algo de lógica personalizada aquí,

00:01:13.936 --> 00:01:18.126 align:middle
pero llamaremos al procesador de estado
normal para dejar que haga el trabajo pesado.

00:01:19.026 --> 00:01:21.006 align:middle
Para ello, añade un método __construct() con

00:01:21.006 --> 00:01:25.456 align:middle
private EntityClassDtoStateProcessor
$innerProcessor. Aquí abajo

00:01:27.196 --> 00:01:33.316 align:middle
, úsalo con return
$this->innerProcessor->process() pasándole los

00:01:33.316 --> 00:01:38.936 align:middle
argumentos que necesita: $data,
$operation, $uriVariables, y $context.

00:01:39.126 --> 00:01:42.926 align:middle
Ah, y puedes ver que esto
está resaltado en rojo.

00:01:43.446 --> 00:01:46.366 align:middle
Esto no es realmente un método
void, así que quítalo.

00:01:47.676 --> 00:01:50.746 align:middle
Bien, ¡vamos a conectar nuestro
recurso API para utilizarlo!

00:01:52.416 --> 00:01:58.226 align:middle
Dentro de DragonTreasureApi, cambia el
procesador a DragonTreasureStateProcessor.

00:01:59.466 --> 00:02:02.416 align:middle
En este punto, en realidad
no hemos cambiado nada:

00:02:02.786 --> 00:02:05.136 align:middle
el sistema llamará a
nuestro nuevo procesador...

00:02:05.376 --> 00:02:08.126 align:middle
pero luego sólo llamará al antiguo.

00:02:08.806 --> 00:02:14.976 align:middle
Y así, cuando ejecutamos las pruebas: Todo
sigue funcionando excepto ese último fallo.

00:02:15.476 --> 00:02:18.236 align:middle
Así que ¡añadamos nuestro
código de notificación!

00:02:18.956 --> 00:02:24.576 align:middle
Originalmente, averiguamos si isPublished
estaba cambiando de false a true utilizando los

00:02:24.626 --> 00:02:28.226 align:middle
"datos anteriores" que hay dentro de $context.

00:02:28.296 --> 00:02:31.646 align:middle
Vuelca $context['previous_data']
para ver qué aspecto tiene.

00:02:32.826 --> 00:02:36.996 align:middle
Ahora, ejecuta sólo esta prueba: ¡Genial!

00:02:37.386 --> 00:02:42.136 align:middle
El dato anterior es el DragonTreasureApi
con isPublished: false..

00:02:42.356 --> 00:02:45.866 align:middle
porque ése es el valor con el que
empieza nuestra entidad en la prueba.

00:02:46.516 --> 00:02:48.096 align:middle
Volquemos también $data.

00:02:51.116 --> 00:02:57.306 align:middle
Vale, ¡el original tiene isPublished:
false, y el nuevo tiene isPublished: true!

00:02:57.616 --> 00:02:59.826 align:middle
Y eso nos pone en peligro.

00:03:00.496 --> 00:03:04.046 align:middle
Volvamos atrás, escribimos el código de
notificación en un tutorial anterior...

00:03:04.336 --> 00:03:05.676 align:middle
así que lo pegaré.

00:03:06.296 --> 00:03:08.626 align:middle
¡Esto es deliciosamente aburrido!

00:03:09.076 --> 00:03:15.576 align:middle
Usamos $previousData y $data para detectar el
cambio de estado de isPublished falso a verdadero...

00:03:16.016 --> 00:03:18.016 align:middle
y luego creamos un Notification. Lo único un

00:03:18.796 --> 00:03:21.796 align:middle
poco interesante es

00:03:21.796 --> 00:03:25.996 align:middle
que la entidad Notification está
relacionada con una entidad DragonTreasure...

00:03:26.296 --> 00:03:31.776 align:middle
así que consultamos la $entity utilizando
la repository y la id de la clase DTO.

00:03:32.666 --> 00:03:37.296 align:middle
Vamos a inyectar los servicios que necesitamos:
private EntityManagerInterface $entityManager

00:03:37.296 --> 00:03:42.296 align:middle
para que podamos guardar y private
DragonTreasureRepository $repository.

00:03:43.686 --> 00:03:44.246 align:middle
¡Ya está!

00:03:44.626 --> 00:03:49.736 align:middle
Momento de la verdad: ¡La prueba pasa!

00:03:50.166 --> 00:03:53.146 align:middle
Demonios, en este punto, ¡todas
nuestras pruebas del tesoro pasan!

00:03:53.626 --> 00:03:59.466 align:middle
¡Hemos convertido completamente este complejo
recurso API a nuestro sistema impulsado por DTO!

00:03:59.766 --> 00:04:00.446 align:middle
¡Choca esos cinco!

00:04:01.376 --> 00:04:06.336 align:middle
A continuación: Hagamos que sea posible escribir
la propiedad $owner en el tesoro dragón.

00:04:06.656 --> 00:04:12.606 align:middle
Esto implica un truco que nos ayudará a comprender mejor
cómo carga la API Platform los datos de las relaciones.
