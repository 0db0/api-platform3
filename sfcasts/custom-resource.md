# Custom Resource

So far, we have *two* API resource classes: Treasure and User. Both of these, if you recall, are actually *entity* classes. But having your API resource on an entity class *isn't* a requirement. You can create any normal boring PHP class you want, add this `#[ApiResource()]` attribute to it, and *bam*! It can become part of your API. *Well*, we still need to do a little work, but we'll see that in a moment.

Why *would* you want to create a custom class for your API instead of using an entity? There are two main reasons. The first reason is because the data you're serving *doesn't* come from the database, *or* it comes from a mixture of *different* database tables. The *second* reason is that the data you're fetching is coming from the *database*, but since your API looks different enough from your entity, you want to clean things up a bit by having a class for your API *separate* from your entity class. We'll address both cases, starting with the first: When your data comes from somewhere other than a database.

Here's the situation: Each day, we post a unique *quest* for our dragons to complete. We want to expose these quests as a new API resource. They'll be able to list all of the *past* quests, fetch a *single* quest by the date, or update the *status* of a quest if they complete it. That's pretty easy. *But* we're *not* going to store this data in the database. We're going to pretend that this data is coming from somewhere else.

Since this data isn't in the database, instead of creating an entity, we're going to create a brand new class and put it in this `/ApiResource` directory. This directory was added *for* us by the API Platform recipe when we originally installed API Platform. It's supposed to be the home for your API resource classes. Create a new PHP class... and let's call it `DailyQuest`. Then, to make this part of your API, just add `#[ApiResource]` to it. That's it! And if we check this out... *boom*! It's *already* in our API documentation. Though, it *does* look a little odd. Notice that the single `GET` is missing. Normally, there's something like `/api/treasure/id` here, but that doesn't exist. We'll talk about *why* in a second.

Another thing to note is that, by default, API Platform looks for this `#[ApiResource]` attribute inside the `/Entity` directory *and* the `/ApiResource` directory, so that's why we put the class there. This *can* be configured in `/config/packages/api_platform.yaml` with a mapping paths configuration so it points to different directories, but I won't show that here because we don't need to configure it.

Okay, so... how could this *possibly* be part of our API? It's just a class, and it doesn't even have any properties yet. If we try the `GET` collection endpoint and hit "Execute"... we get a 404. *So* it's not *actually* working. And if we try the `POST` endpoint... we're just sending empty data. It actually gives us a 201 status code as if it was *successful*, but behind the scenes, nothing happened. No data was created *or* saved.

If we look back at my favorite "upgrade" part of the documentation that talks about providers and processors, this is where you'll find all of the processors and providers that you get *by default* when you're using a Doctrine entity as your API resource. As it turns out, that's really the only difference between an API resource on a random class and an API resource that's on an entity. When you use `#[ApiResource]` on an *entity*, API Platform automatically gives you a processor and provider for all of your operations. When you create a *custom* class, you have no providers *or* processors. This means that API Platform doesn't know how to *load* the data when you make a `GET` request, and it doesn't know how to *process* the data when you make a `POST` request. That's *our* job! Let's do that *next*.
