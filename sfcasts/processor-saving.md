# Processor Saving

In our state processor, we have *successfully* transformed the `UserApi` object into our `User` entity object. So let's save it! Saving things is pretty easy. We *could* inject the entity manager, persist and flush that entity, and be done with it. But we still want to offload as much work as we can to the core Doctrine processor. And, as it turns out, the Doctrine processor is *fairly* complex. It's called `PersistProcessor`, so let's search for that.

For the most part, it's doing things like persisting and flushing. But it *also* has some pretty complex logic here for things like `PUT` operations. We're not really using those, but it just goes to show that we have *a lot* more going on here. To save some time, let's use *this* instead of trying to roll our own logic.

The way we do this should be pretty familiar at this point. We're going to say `private ProcessorInterface $persistProcessor`. And so Symfony knows *precisely* which service we want, we'll use the `#[Autowire()]` attribute, pass `service`, and we can say `PersistProcessor` (in this case, there's only one `PersistProcessor` to choose from) `::class`. Very nice! Then, down here, we'll say `$this->persistProcessor->process()` with `$entity`, `$operation`, `$uriVariables`, and `$context`, which are all of the same arguments we're passing up here.

Now, there's one thing you may have noticed here, which I mentioned earlier. When it generated this class, it generated it with a `void` return type. That's not exactly true. You don't *have to* return anything from the state processors, but you *can*. And whatever you *do* return - in this case, we'll return `$data` - will ultimately become the object that is serialized and returned back to the user. If you don't return it *anything*, it's going to use this by default. This won't really change anything, but it's important for you to at least be aware of it.

Okay, so this *should* save the database and serialize. Let's try it! (Famous last words...) And... it *doesn't* work. We're still getting a 400 error, and it's *still* `Unable to generate an IRI for the item`. So... what's going on? Let's think about it. Our `UserApi` object *still* doesn't have an ID. So we map it to a new `User` object, *save* the new `User` object, and Doctrine *gives* that new `User` object an ID. *But* we never put it back onto our `UserApi` object. Our ID is just floating around in space! But never fear! This is an easy fix. Right here, say `$data->id = $entity->getId()`... and if we try it now... it *still* fails, but we actually got a little further this time.

We can see that the response *did* work. It has a 201 status code, and it returned with our new user information. It's *failing* on the part of the test where it tries to then *use* the password to log in. That's because our password is currently set to a `TODO`. We'll handle that in a moment, but *first*, I want you to notice something. When we set the `processor` on the top level `#[ApiResource]`, this becomes the processor for *all* of the operations: `POST`, `PUT`, `PATCH`, *and* `DELETE`. Now `POST`, `PUT`, and `PATCH` are all pretty much the same. They're just saving the object to the database. But `DELETE` is different, right? When we use `DELETE`, we're trying to *remove* something from the database. That's not really a problem. We just need to make sure that we handle that situation up here.

After we map our API object to the entity, we need to figure out if we actually need to *delete* that entity. To do that, we can check `if ($operation instanceof DeleteOperationInterface)`, and if it *is*, we want to *delete* that entity. Again, deleting isn't hard, but we're going to offload this to the core Doctrine remove processor. So, up here, copy this argument... and let's inject *another* processor. This one is going to be `RemoveProcessor`, and we'll rename this to `$removeProcessor` as well. Perfect! Then, down here, we can say `$this->removeProcessor->process()` and pass `$entity`, `$operation`, `uriVariables`, and `$context` just like the other processors. A key thing to note here is that we're going to `return null`. In the case of a `DELETE` operation, we don't return anything at all, so we're returning `null` from here, I don't have a test set up for that at the moment, but we'll take a leap of faith and just assume that works like it's supposed to.

Now let's tackle our last problem, which is hashing the plain password. We've done this before, so nothing's super new here. We're going to check to see if our DTO has a password, but before we do that, we actually *need* a password. We haven't added that yet, so let's open `UserApi.php`. To add a password, say `public ?string $password = null`, and we'll also add a comment here. So, in the case of the API, this is always going to be the `plaintext` password. We're *never* going to pass around a hashed password on our API. That doesn't make any sense. We'll note that this is `The plaintext password when being set or changed.` Perfect.

Back in our processor, `if ($dto->password)`, *then* we know we need to hash that and save it on the user. The password *must* be there because all users will need that when they create an account. But if we were just *updating* a user, like changing their username to something else, that exchange wouldn't have a password, so there's nothing to hash. I'll undo that really quick. But if there *is* a password, that means the user is either setting a new password or updating an existing password. *That* will require hashing.

Up here, we need to add one more argument: `private UserPasswordHasherInterface $userPasswordHasher`. And down here, say `$entity->setPassword()`, which is the hashed password, set to `$this->userPasswordHasher->hashPassword()`, passing that the `$entity` (the user object), and the plain password, which will be `$dto->password`. *Phew*. Let's try that again. And... it *fails*. My error says:

`The annotation "@The" in property App\
ApiResource\UserApi::$password was never imported.`

So... this is me accidentally having an extra `@` in there and it thought it was an annotation. I'll remove that... and if we try again... it *passes*, which means it fully logged in using that password. It works! *But*, look at the dumped JSON response. This is after we `POST` to create the user. When it returns, it's returning the `password` property and the plain text password that the user just set. *Whoops*.

Okay, let's make sure we *completely* understand this. Our provider is used for all of the `READ` and `GET` endpoints, and it's also used for the `PATCH` endpoint. And one of the key things you'll notice here is that we're *not* setting a password, because we don't *need* to set the plain password onto our `UserApi`. We don't want to return that field to the `UserApi`, so we're, quite correctly, not mapping it from our entity to our DTO right. That's *good*. But when you do a `POST` request, this is the *one* situation where the provider is never called. This data is directly deserialized into our `UserApi` object that's passed to our processor. *That* means our DTO *does* have the plain password on it and, ultimately, it's *that* DTO with the plain password that's returned to the user. In any case, even if we made a `PATCH` request, it would load our `UserApi` object with *no* password and deserialize the password onto it, which means we would end up in the same situation with a `UserApi` object that *has* a password that's returned to the user.

This is a really long way of saying that, in `UserApi.php`, this password is meant to be a write-only field. The user should *never* be able to *read* this field, only *write* it. *So* let's talk about how we can do customizations like this inside of our `UserApi` class, while avoiding the *complexity* of serialization groups. That's *next*.
