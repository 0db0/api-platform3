# Micro Mapper

Doing the data transformation, from the `UserApi` to the `User` entity, or the `User` entity to the `UserApi`, is the only part of our provider and processor that isn't generic and reusable. *Darn*. If it wasn't for this code, we could quickly create a "DragonTreasure" API class and do this whole thing over again with almost no work. *Fortunately*, this is a well-known problem called "data mapping".

For this tutorial, I tried a few libraries to help us out, most *notably* the jane-php/automapper-bundle, which is super fast, advanced, *and* fun to use. However, it isn't *quite* as flexible as I needed it to be, and extending it looked like it was going to be complex. I honestly got stuck in a few places, so I hope that library proves me wrong. It was *very* cool, so it could have just been user error. I also know some of the people that work on it, and they're *awesome*. The point is, we're not going to use that library. *Instead*, to handle the mapping, I created a very small library of my own that we're going to reuse in this tutorial. It's easy to understand, and gives us *full* control, even if it's not quite as cool as jane-php's automapper. So let's get it installed! Run

```terminal
composer require symfonycasts/micromapper
```

which kind of sounds like a superhero.

When that installs, we now have a new micromapper service that we can use. Woohoo! And here's how we're going to do it. Let's start with the *processor*. Up at the top here, we're going to inject `private MicroMapperInterface($microMapper)`. And down here, for all of the mapping stuff, we can copy this, since we're going to reuse a bunch of it in a moment. And then, all we're going to say is `return $this->microMapper->map()`. This has two main arguments: The `$from` object, which is going to be our `$dto` from, and the *toClass*. We want to convert this to a `User` entity, so say `User::class`. And that's it! Well... not *quite*, but let's try running our `testPostToCreateUser` anyway. And... it *fails* with a *500* error. The really interesting thing about this is what that 500 error *is*. Let's actually "View Page Source" so we can read this even better. Here, it says `No mapper found for app\\UserResource\\UserApi -> App\\Entity\\User`, and this is coming from `MicroMapper.php`. This is basically saying:

`Hey, I don't know how to convert a UserApi object to
a User object!`

MicroMapper *isn't* magic. We're doing everything by hand. So the way we're going to do this is by creating a class that *explains* how to do this transformation. That's called a *mapper class*. These are fun! We'll start by closing a few things... and creating a new `/Mapper` directory in `/src`. Inside of *that*, create a new PHP class called... how about `UserApiToEntityMapper`, because we're going from `UserApi` to `Entity`. And there's *two* requirements we need. This needs to implement a `MapperInterface`. Perfect. And then above it, to describe what it's mapping *to* and *from*, we're going to add an `#[AsMapper()]` attribute with `from: UserApi::class` and `to: User::class`. That's how the MicroMapper will know to use *this* when we're going in that direction.

Since we've implemented this *interface*, go to "Code Generate" (or "command" + "N" on a Mac) and implement the two *methods* that we need - `load()` and `populate()`. And, for starters, let's `dd($from, $toClass)`. Now, just by creating this and giving it `#[AsMapper]`, when we use the MicroMapper and try to do that transformation, it *should* call our `load()` method. So let's try it! Let's rerun the test again, and... got it! Perfect! *There's* the `UserApi` object we're passing, and *it's* passing us the `User` class. We have two methods inside of this. The purpose of `load()` is to *load* the `$toClass` object and return it. In our case, it's going to load it from the database, so we're going from a `UserApi` to a `User` entity. We basically want to load the `User` from the *database* or return a *new* `User` if we need it. I'll show you.

We're going to say `public function __construct()`, and we'll inject our normal `UserRepository $userRepository`. Down here, this is going to be the same code that we saw earlier. For sanity's sake, we're going to say `$dto = $from`, and below that, `assert($dto instanceof UserApi)`. That will help our brain *and* our editor. And then the `$userEntity` is going to be like this: *if* our `$dto` has an `id`, then we're going to use `$this->userRepository->find($dto->id)`, *else* we're going to create a `new User()` object. It's *that* simple. And that's why the purpose of the `load()` method is either "load it from a data source" or "just create a new object".

Just for clarity, and to help give us a better error, it, for some reason, we don't have a `$userEntity`, `throw new \Exception('User not found')`, similar to what we did before. And down here, we'll `return $userEntity`. So we've initialized our `$to` object and returned it. Now whatever we return from the `load()` method, that's immediately going to call `populate()`, pass us the `$from` object, and then it will pass the `$userEntity` - the "to" object. So we can see what's happening, we'll `dd('$from, $to)`. And now let's run it. Perfect! Here's our "from" `UserApi` object, and here is our *new* `User` object.

Now... you might be wondering why we have both a `load()` method and a `populate()` method, when it seems like these could just be *one* method. And you'd be right! But there's actually a technical reason why they're separated, and it's going to come in handy later when we talk about relationships. For right now, you can just think of this as one method. This is where we *load* the object from the database, and down here is where we *populate* all of the properties, taking them from the `$from` and putting them onto the `$to`. Once again, to keep us sane, we're going to say `$dto = $from` and `assert($dto instanceof UserApi)`. And we'll also do the same thing for `$from`. Say `$entity = $to` and `assert($entity instanceof User)`. The code down here is going to be really normal and boring, so we'll go through this quickly. And at the bottom, we'll `return $entity`. We're using the `userPasswordHasher` here, so we *also* need to make sure, at the top, to say `private UserPasswordHasherInterface $userPasswordHasher`. So this is basically the same code, but in a different location.

Okay! Let's try that test again. And... it *passes*! This is *huge*! We've offloaded all of this work to our mapper and processor, and it's almost completely generic. Now we can remove the old `UserPasswordHasher` since we don't need that anymore, and we can also get rid of the `UserRepository` up here. We can even remove those `use` statements. Perfect! We still have to do the work for mapping, but now we have all of this in a nice central location.

Now we can *repeat* this for the provider. Go ahead and close the processor... and open up our provider. In this case, we're going from the `$entity` over to `UserApi()`, so we're just going to copy all of this code here, *delete* it and, just like before, we're going to autowire `MicroMapperInterface $microMapper`. Down here, this simplifies to `return $this->microMapper->map()`, and as I said earlier, we're going from our `$entity` to our `UserApi::class`. Sweet! If we tried this now, we'd get a 500 error because we don't have a mapper for it just yet, so let's create that first.

In `/src/Mapper`, we'll create a new class called `UserEntityToApiMapper`, and here, let's implement the `MapperInterface`. Above that, we'll add `#[AsMapper()]`. In this case, we're going `from: User::class, to: UserApi::class`. Then, we can implement both of the methods we need... and start pretty much the same way as before, with `$entity = $from` (just for my own sanity), and then `assert($entity instanceof User)` to help out my editor. Down here, we'll create the `$dto`. There's no query in the database for the DTO, so we'll always create a fresh new `UserApi()` object, and then we'll set set the ID onto it with `$dto->id = $entity->getId()`. *Finally*, we'll `return $dto`. The job of the `load()` method, in this case, is to not only create the `UserApi` object, but make sure that it has the identifier on it. So our work in `load()` is *finished*.

Everything else we need to do is down here in `populate()`. We'll start the same way we did before, with `$entity = $from`, `$dto = $to`, and two asserts: `assert($entity instanceof User)` and `assert($dto instanceof UserApi)`. Below that, we're going to use the exact same code we had before. We're just transferring the data. At the bottom, `return $dto`.

Okay, let's try this! Head over to your browser, refresh this page, and... *oh*... `Full authentication is required to access this resource`. *Of course*. That's because we added security! Head back over to the homepage really quick, click this username and password shortcut... *boop*... and *now* try to refresh that page. And... it *works*! We *are* missing some of the data, though, which is my fault. I said    `$dto = new UserApi()`, so instead of *modifying* the `$to` object I'm being passed, I was actually creating a *new* one and the original wasn't being modified. There we go. If I try again... it's working *much* better.

So this is *huge*. Our provider and processor are now *completely* generic. Let's finish the process of making them work for *any* API resource class *next*.
