# State Options Part1

Coming soon...

When we create a non-entity API resource, we are responsible for loading and saving
the data. With an entity, we get to use the built-in state providers and processors,
which is what makes them so awesome. What's frustrating is that if we make a custom
state provider for our new UserAPI class, it'll basically need to do the exact same
thing as the core doctrine state provider. It needs to query the database. So it's a
bummer to need to reinvent all of that logic inside of our custom provider.
Fortunately, there is now a way to have a non-entity API resource, but reuse the core
doctrine provider and processor functionality. So first, if we're talking about the
collection operation, the core provider from doctrine is called CollectionProvider.
I'm actually going to look in all places and open the one from the ORM. So if you
ever want to see what the CollectionProvider looks like, here it is. And you can see
it's actually more complex than you even might think. It creates the QueryBuilder. It
calls this thing called HandleLinks, which is a thing that intelligently joins to
other tables based on the data you need. It has the extensions system. This is
actually something we talked about in the previous tutorial, where we could create a
query extension. We actually did this for a dragon treasure so that it would only
return dragon treasures that were published. And part of that extension system,
though we can't see it here, is actually what adds pagination and filtering to
doctrine entities. So the CollectionProvider gives us the extension system, filters,
pagination, and takes care of all the query. It does so much good stuff for us. I
just want to reuse it. So you know what? I'm going to try. I'm going to go over into
my user API. I'm going to say Provider, and I'm going to point at CollectionProvider,
the one from doctrine ORM, and just see what happens. All right, over here, let's
actually just go to the endpoint directly, slash API slash users dot JSON-LD. And we
are greeted to an error. Call to a member function, getRepository on null, coming
from the core CollectionProvider. Not surprising. Our user API is not an entity, so
it tries to figure out how to query for it, and it explodes. But you're ready for the
secret. There's a way that we can hint to the system that the data for this class
should come from the user entity. It looks like this. Add a state options here, set
to a new options object. Make sure you get the one from the ORM. And then here, say
entity class, and set it to user colon colon class. Now, let's see what happens. If I
go over and refresh, whoa, it looks like it works. Check this out. Total items 11,
and you can see items 1 through 11 right here. Though we only have an ID property.
But I guess it makes sense, because inside of our user API, we only have an ID
property. So let's try adding a couple other properties, a public string email, and a
public string username. These are both properties that we have over here in our user
entity as well. And when we refresh, those pop up.

So that works, but what the heck is going on? So in essence, the underlying API resource objects, like if you could look internally inside of API Platform, are user API. So what we're seeing here is a collection of user API objects. But there are several places in the system that look for this new state options. And if it's present, it uses the entity class from that. The collection provider that we had open a second ago, let me open it again, the one from Doctrine ORM, is one of these cases. That's what's happening up here. It grabs the entity class from the state options if there is from the state options if there is one, and it uses that when it does the query. In fact, as soon as we have this state options thing, Doctrine API Platform actually sets the provider and the processor automatically to the core Doctrine provider and processor. So we don't even need to have that provider on there. It's already set for us. Okay, but if behind the scenes, the provider is querying for user entity objects, how and when is that converted to user API objects so that the user API object can return to the JSON? And the answer is during serialization. It's kind of strange. So thanks to the state options, API Platform adds... During serialization, it's actually serializing the user entity object. But to get the list of the properties that it should serialize, it actually reads the user API. So it reads these properties off of the user API, grabs those off of the user, and puts them onto a user API. So another way to kind of think about it is it serializes the user entity into a user API and then to JSON. It's kind of strange. And it actually has a major limitation. Watch. Let's try adding a property that is not on our entity. So how about public int flame throwing distance equals zero. So there is no flame throwing distance property over here on my user entity. As soon as we do this, explosion. And you can see the explosion if you scroll down a little bit, is eventually coming from the normalizer system, which is the normalizer from the normalizer system, which is part of the serializer system. So it basically looks at the user API, says, oh, I need a flame throwing distance property, tries to fetch that off of user. It's not there. We get this big exception. So the big limitation is that we can't have extra fields on our user API class with this strategy. And that is a huge limitation, but one that we will fix nicely in the next chapter. So for now, I'm going to remove this extra property. By the way, one other limitation that you may have noticed, which will also fix is the fact that we don't have the JSON LD fields here, we don't have the at ID, or the at type, as I mentioned, we'll fix that the same time that we fix that problem with custom fields. Alright, so let's add another property to this. How about public array dragon treasures. And we do have a dragon treasures property over on our user. And that holds a collection of dragon treasure objects. So if we go over here, that works fine, though, a little surprisingly, it actually embeds the dragon treasures instead of it turns them as a IRIs. This is the same problem that we saw earlier. And the fix is the same, though, I do want to point out one kind of cool thing. When it embeds the dragon treasure, one of the properties of dragon treasures owner, right now that owner is actually the user entity. Since the user entity is no longer an API resource, it actually uses that kind of random gen ID thing again, we're going to fix that soon. As I'll talk about in a little bit, once you kind of once you start creating custom classes using custom class instead of NC entities, you kind of want to use it for all of your API resources instead of having a mixture. But more on that later. Point is to turn that to fix this, we just need to advertise that this is an array of dragon treasure. And I'm just going to use a different array syntax there doesn't really matter. And now recognizes that and it serializes it correctly. So far, okay, so far, we know that the state options thing does three things. One, it automatically sets the provider and processor to use the core doctrine provider and processor. To the provider is smart enough to query from this entity. And this also works for single items. So slash users slash one dot JSON LD. Awesome. And three, the serializer kind of serializes the user entity into the user API class. That does have that big limitation of not not allowing custom fields, but more on that soon. Now, the fact that the state options causes the core doctrine state provided to be used has some hugely important side effects that I kind of talked about at the beginning. The first thing is that we get pagination for free. Watch let's add pagination items per page five. And I go over and refresh text out total items 11. But it only shows five and we have the pages down there. The second thing is the collection provider also makes the extent the query extension system work. So we don't have any query extensions for user we have but we do have one for dragon treasure. So as you're going to see later when we convert dragon treasure to its own DTO class, this extension is still going to be called it's still going to work. And the third and final thing is that the filter system still works. So check this out. Above user API, I'm gonna use API filter. And let's use search filter, colon colon class properties. And here, we'll set username partial. Go back and look at the documentation. Whoops, hold on, I messed something up. I got the search filter from doctrine ORM. Don't do that. Oh, RM, there we go. Now, if we refresh the documentation, you assume you look at the user's endpoint, it is advertising that there's a username filter and it is going to work. So I'm actually going to do a little shortcut here and say question username equals. And I'm going to question username equals. And let's say clumsy. And you can see it's only returning those results right there. Just those four, I guess five total results. I will do that when I finish recording this. Give me a second. So even the filter system is working. Though one note here, when we say username, we're actually referring to the username property on user. So actually, like, we don't even need to have username here. We're not referring to that username property, we're kind of hinting to the entity system, which property on the entity do we want to query from. So this is so awesome, we're reusing all this core doctrine logic, pagination filters, it's the best thing ever, except for that big, crazy, huge limitation that our DTO can't have custom fields. And that's really the whole point of a DTO, to have different fields than your entity. So let's see how to fix that limitation next.
