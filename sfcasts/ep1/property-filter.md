# Property Filter

Let's add *one more* filter. We have three right now, but *maybe* we want to filter the *value*, like within a range. There's actually a built-in filter for that called the `RangeFilter`. Find the `$value` property and, like we did before, use `#[ApiFilter()]` and inside that, `RangeFilter` (the one from ORM) `::class`. This one doesn't need any other options, so... we're done! Dang... that was easy. When we refresh... open it up, and hit "Try it out".... look at that! We have *a ton* of new properties - `value[between]`, `value[gt]` (or "greater than"), `value[gte]` ("greater than or equal to"), etc. Let's try `value[gt]`... and, I'm sort of picking a random number here... maybe `500000`... and when we click "Execute"... you can see that it updated the URL here. The URL looks a little ugly because of the URL encoding, but it *works*. If I look down here... cool. Apparently that just returned 18 results.

Alright, the *last* filter I want to show you isn't really a filter at all. It's a way for us to allow our API clients to *choose* which fields they want returned. To show this off, find your `getDescription()` method. Let's pretend that we want to return a shorter, truncated version of the description. To do this, I'm going to copy the `getDescription()` method, paste it below, and create a new method called `getShortDescription()`. To *truncate* this, we're going to use the `u()` function from Symphony. Type `u` and make sure to hit "tab" to autocomplete that. This is a rare function that we have in Symphony, and hitting "tab" *did* add a `use` statement for it. You can see that we have a bunch of nice methods on this, but the one we want is called `truncate()`. We'll truncate this at `40` characters, followed by a little `'...'`. *Cool*. Right now, this is a perfectly normal and *functional* PHP method. To expose this to our API, above this, we just need to add the `Groups` attribute with `treasure:read`. Beautiful!

Okay, let's head back to the documentation and refresh. If you open the `GET` endpoint, hit "Try it out", and then "Execute"... *nice*. Here's our truncated description! But you may have noticed that now, we have *two* descriptions - the short one and the regular one. If our API client requests the short description, it may not want us to *also* return the full-length description, for the sake of bandwidth or just general sanity. To help with this, we can use the `PropertyFilter`. Let's head back to `DragonTreasure`. This is a filter that has to go *above* the class, so right here, say `ApiFilter`, and then `PropertyFilter` (in this case, there's only *one* of them) `::class`. We also have some options we can pass to this, which can be found in the documentation, but, for our purposes, we don't need any of them right now. So... what does that *do*?

If you head back, refresh the documentation, open up the collection endpoint, and hit "Try it out"... we now see `properties[]` here and we can add a "string item" to it. Let's do that! Add a new string item called `name` and another one called `description`. Cool! Down here, I'll hit "Execute", and... there it is! It just popped these onto the URL like normal. But look at the response. It *only* contains the `name` and `description` fields. Well... it contains the JSON-LD fields. It will *always* contain those. But the *real* data is *just* those two fields. It's still returning all 40 items, but *only* those two fields. If we removed our string items, we'll get the normal response with *all* of them. So, by default, you get *all* of the fields, but it *is* possible to control *which* fields you get.

This *works*, but if you look at the API Platform documentation for the `PropertyFilter`, they actually recommend a different solution - something called "Vulcain". Nope, not Spock's home planet. We're talking about a protocol for your web server that can add features to your web server. It was created by the API Platform team, and if we scroll down a bit, they have a really good example of how it works.

Let's pretend that we have the following API. If we make a request to `/books`, we get these two books back. Simple enough. Then maybe we want to get more information about the *first* book, so we make a request to *that* URL - `/books/1` - to see the title and author. All right, now we want more information about the author, so we'll make a request to this URL - `/authors/1` - to see the author's first and last name. So if we make a request to `/books` to get all of the information we might need, we'll actually end up making *four* requests in total - the original request, plue three others as we look for more information about the author. That's *not* really convenient. What Vulcain allows you to do is just make this *first* request, but tell the server that it should push the data from the other requests to you.

We can see this best in JavaScript, and there's a little example of that down here. It's really easy. All we need to do, when we're using JavaScript, is use the `fetch()` function, and tell it to `fetch("/books/1")` followed by this special `Preload` header. A better example of the `Preload` is up here - `Preload: "/member/*/author"`. That's basically going to tell our server to look at any URLs that match that pattern and follow them. I won't go into the specifics on this, but briefly, `/member/*` is going to match `/member/` *all of these*, and then `/author` will follow the `author` key once it fetches those books. The end result of passing the `Preload` header is that our API will return the normal response for `/books`, while *also* pushing the other URLs to us. In this case, it's going to push the data for `/books/1`, `/book/two`, and `/author/1`.

Down here, we have a slightly different example where we're just fetching `/book/1` with `Preload: '"/author"'`. When we do this, our book response will be completely normal. The *key* is that, a second later, if we tried to use `fetch()` again on `bookJSON.author`, it will return *immediately*. It won't make a second AJAX request because we *already* have that data. So we're writing our JavaScript like normal. All we need to do is add a new `Preload` header and we'll reap the rewards of the extra performance. That's basically all we need to know about Vulcain for now, so I won't dive any deeper into this topic. I just wanted you to be aware of this, because it can be a *very* powerful feature in your API.

Next: Let's talk about *formats*. We know that our API can return JSON-LD, JSON, and even HTML representations of our representations. Let's add two *new* formats, including a CSV format, which is going to be the *fastest* CSV feature you've ever built.
