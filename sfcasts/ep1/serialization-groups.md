# Serialization Groups

Right now, a field being *readable* or *writeable* in our API is determined by whether or not it's *accessible* in our class (basically, whether or not it has a getter or a setter method). But what if you need a getter or setter but *don't* want that field exposed in the API? For that, you have two options.

Option *one* is to create a DTO class for your API resource. This is something we're going to talk about more in-depth in a future tutorial, but in a nutshell, it's where you create a dedicated class for your `DragonTreasure` API, which likely has a lot of the same fields as this, and then you *move* the API resource onto *that*. It takes a little more work to set things up, but the advantage is that you'll then have a dedicated class for your API. So you'll literally always make your class look exactly like you want it to look in the API, and then you're *done*.

The *second* solution, and the one we're going to use, is *serialization groups*. Check this out. Over on our API resource, we're going to add a new option here called `normalizationContext`. If you'll recall, "normalization" is the process of going from an object to an array, like when you're making a `GET` request to read a treasure. The `normalizationContext` is basically *options* that are passed during that process, and the one option that's most important by far is `groups`. We're going to pass a new group here called `treasure:read`. We'll talk about what this does in a minute, but you can see the pattern for the name I'm using here is basically just the name of my class (it could be `DragonTreasure` if I wanted) and then `:read`, because the normalization means that we're *reading* this class.

So... what does that *do*? Let's find out! I'm going to refresh the documentation and, to make life easier, we'll just go to the URL directly. Oh, whoops... it's not called "dragon_treasures" anymore, just "treasures". There we go. And... absolutely nothing is returned anymore. Check this out. This `hydra:member` is our array of resources, and it's returning one treasure. Other than these weird `@id` and `@type` fields, there are no actual fields being returned from our resource.

Here's how this works. Now that we have this `normalizationContext` on here, when our object is normalized, it's only going to include properties that have this group on it. And since we haven't *added* groups to any of our properties, it returns *nothing*. How do we add groups? We do that with *another* attribute. Above the `$name` field, we'll say `Groups()` and hit "tab" to add a `use` statement, and then `treasure:read`. We'll do this again above the `$description` field because we want *that* to be readable... and then the `$value` field... and `$coolFactor`. That's a good start. Let's go over and refresh our endpoint, and... got it! We can see `name`, `description`, `value`, and `coolFactor`.

We now have control over which fields are *returned*, and we can do the same thing for the fields that are *writeable*. That's called "de-normalization", and I bet you can guess what we're going to do here. Copy that, paste... change this to `denormalizationContext`, and we'll say `treasure:write`. Right after that, we'll head down here and add `treasure:write` to the `$name` field. I'm going to skip `$description` for now (Remember that we actually *deleted* our `setDescription()` method earlier). We'll also add this to the `$value` field... and the `$coolFactor` field. You can see that it's mad at me because I forgot something important. As soon as you pass *multiple* groups in here, we need to make this an *array*. So I'll add some `[]` around those three properties. There we go. Now these properties are in *both* groups. To see if this is working, I'll go refresh the documentation... open up the `PUT` endpoint, and... nice! We see `name`, `value`, and `coolFactor`, which are now the *only* fields that are *settable* on our API.

We *are* missing a couple of things, though. The last time we made a `getPlunderedAtAgo()` method, and we want this to be included when we read our resource. Right now, if we we check our endpoint, it's *not* being included., so we can add the *same* group above our methods. Say `#[Groups(['treasure:read'])]`, and when we go check... *now* it pops up. Let's also find the `setTextDescription()` method, and do the same thing there: `#[Groups([treasure:write])]`. Awesome! If we head back to the documentation, you can see that this was not there a second ago. If we refresh and check out the `PUT` endpoint again... `TextDescription` is *back*. This means, if we want to, we can restore some of the setter methods we removed a second ago.

Maybe I *do* need a `setDescription()` method in my code to be able to do things, so I'm going to copy `setName()` to be lazy, paste, then change "name" to "description" in a couple of places. Got it! And the nice thing about this is, even though I have that setter back, now when I look at my `PUT` endpoint, it *doesn't* automatically show up because we have complete control, thanks to our denormalization fields. I'm going to do the same thing for `PlunderedAt()` as well. Sometimes it's handy, in your data fixtures especially, to be able to *set* `PlunderedAt`, so I will quickly add that. I *could* have been lazy and generated the setter, but that's okay. We're done.

So we know that *fetching* a resource works. Now let's see if we can *create* a new resource. I'll click on the `POST` endpoint, hit "Try it out", and... let's fill in some information about our new treasure, which is, of course, a `Giant jar of pickles`. This is *very* valuable and has a `coolFactor` of `10`. I'll also add a description, but this jar of pickles really speaks for itself. When we try this... oh... we get a 500 error:

`An exception occurred while executing a query: SQLSTATE[23502]: Not null violation: 7 ERROR: null value in column \"isPublished\" of relation \"dragon_treasure\" violates not-null constraint [...]`

We have reduced our API down to *just* the fields that we want to be writeable, but we're *still* missing one field that needs to be set in the database. If you scroll up and find `isPublished()`... you can see that it currently equals `null`. Let's change that to `= false` by default, and then we don't need that `?` in front of `bool`. The property's not nullable anymore, so now if we try it... the `Giant jar of pickles` is loaded into the database! It works!

Next: I want to show you a few more cool serialization tricks that'll make your class and API *awesome*.
