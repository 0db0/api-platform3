# Subresources

We have *two* different ways to get all of the `dragonTreasures` for a specific user. First, we could just fetch the `user` and read its `dragonTreasures` property. The second way is via the filter that we added a moment ago, where you can actually use the Treasure collection endpoint with a filter on it. In the API, that just looks like `?page=1&owner=%2Fapi%2Fusers%2F4`, and then you get the collection endpoint. This is *my* favorite way of doing it, because if I want to fetch treasures, I should use the `treasures` endpoint. But we can also use API Platform to get something like a *vanity* URL. *Fancy*. For example, imagine that, to get this same collection, we want the user to be able to go to `/api/users/4/treasures.jsonld`. That, of course, doesn't actually work, but it *would* be pretty cool. That is called a *Subresource*, and they're *much* nicer in API platform 3.

Okay, let's *think*. This endpoint will return a treasure, so to add this *Subresource*, we need to update the `DragonTreasure` class. If we spin over here... we're actually going to add a *second* `ApiResource`. We already have our *main* `ApiResource`, and, up here, let's add the new one. This time, we're going to control the URL with a `uriTemplate`. We can put exactly what we're looking for here: `/users/`. For the wildcard part, let's put `{user_id}` (we'll see how that's used in a moment), followed by `/treasures`. And that's it! Well... I'll also add `.{_format}`. This is *optional*, but it's what allows us to cheat and add this `.jsonld`, so if you want this to work on your new endpoint, make sure you include that extra code.

In our case, for `operations`, we don't need *all six* operations. This really represents a *single* operation, so we'll set `operations` to `[new GetCollection()]` because we're going to be returning a *collection* of treasures for this particular user. And... done! If we head back to the documentation and refresh... suddenly we have *three* resources, and this one has the correct URL. We have *three* resources because, if you'll recall from earlier, we *customized* our `shortName`. Let's actually copy that and paste it here so they match. And to make PhpStorm happy, I'll put them in *order*. Now if we refresh... perfect! That's what we want!

We now have new operation for fetching our treasures. But does it *work*? It *says* that it will retrieve a collection of treasure resources, so that's good, but... we have a *problem*. It thinks we need to pass the `id` of a `DragonTreasure` here, but it should be a `user`. And even if we pass something there, like `4`, and hit "Execute"... look at the URL! It didn't even use that `4`, and it has the `{user_id}` in the URL. So *of course* it came back with a 404 error. We still need to define what this `user_id` is. We understand that it's the ID of the user, so we need to describe that.

Add a new option called `uriVariables`. This is where you describe any wildcards that you have in your URL, so let's pass the `user_id` set to a `new Link()` object. There are multiple options here, but we want the one from `ApiPlatform\Metadata`. Now, we need to put *two* things in this `user_id`. First, we're going to point it at the *class* that this is related to. We'll use the `fromClass` option and set it to `User::class`. The *second* thing we're going to do is define which *property* on user points to `DragonTreasure`. We're going to point it at the property that forms the relationship using `fromProperty` set to `treasures`. The idea here is that this `user_id` is meant to find a *user*. And then the relationship between the user and the treasures is defined on this `treasures` property. But *actually*, that's not correct. This is defined on the `dragonTreasures` property. That was a silly mistake that *probably* made this a little confusing, but we're back on track.

Head back over and refresh. Okay... we see our endpoint here. And look! It says "User identifier", so it *knows* that this is meant to be a user. Let's put `4` in there again, hit "Execute" and... *got it*. There's our *five* treasures for that user. If we look over here and refresh are the URL... it *works*. Behind the scenes, thanks to our link, this basically makes the following query: `SELECT * FROM dragon_treasure WHERE owner_id =` and whatever we pass for `user_id`. It knows how to make that query by looking at the Doctrine relationship and figuring out which columns are used in that query. It's *super* smart. We can actually see this at work in the profiler. Go to `/_profiler`, click on our request right there and, down here, we can see that Doctrine query. Both of these are basically the same query. This is the one that's used for pagination. If you click on "View formatted query", you can see it. It's even more complex than expected. It has an `INNER JOIN` here, but it's basically selecting all the Dragon data where `owner_id` equals the ID of that user.

By the way, if you look at the documentation, there's also a way to do this with `toProperty: 'owner'`. There's no problem with it this and it will still work, but it's best to stick with `fromProperty`, which is consistently more clear. This `toProperty` is needed if you didn't map the *inverse* side of the relationship, like, for example, if there was no `DragonTreasure` property on user. Unless you have that exact situation, always use `fromProperty`. It's just simpler.

There *is* a *tiny* problem here, however. If you look back at our data, it's got the wrong *fields*. It's returning *everything* like `id` and `isPublished`. Those generally aren't returned because of our normalization groups. We specify normalization groups on the API Resource, so they're being returned because they're missing from down here. There are no groups, and it just serializes everything it can. That means we need to grab our `normalizationContext` and add it down here. We don't need to worry about `denormalizationContext` because we don't have any operations that use denormalizing. If we refresh now... got it!

Okay, let's add one more endpoint. I'll show it to you in the URL first. We have a treasure with an ID of `11`. Let's say that we want to have something that looks like this: `/api/treasures/11`. If we try to navigate to that right now... we, of course, will get the information about that. But what if we want to be able to add `/owner` to that to just get the user? Right now, that doesn't work, but we *can* add that with a Subresource. Because the resource that will be returned is a user, *that's* where we need to add this new API Resource.

Above that class, keeping this near the other resource, add `#[ApiResource()]`. Inside, set `uriTemplate` to `/treasures` with `/{treasure_id}` as the wildcard (though this can be anything), followed by `/owner.{_format}`. The next step is to pass in the URI variables. We only have this one, `treasure_id`, set to a `new Link()` - the one from `ApiPlatform\Metadata` - and we'll use a normal `fromClass`. This is referring to a `DragonTreasure`, so we'll say `DragonTreasure::class`. Above that, the *property* on `DragonTreasure` that refers to this relationship is `owner`, so we'll say `fromProperty: 'owner'`. We also know that we're going to need the `normalizationContext` down here, so let's copy that and paste it here. Finally, we only want *one* operation, so add `operations`, which will return a single user using `new Gte()`. That should do it! Move back over to the documentation, refresh, and take a look under "User"... yep! We have a new resource! And it even sees that this is the "DragonTreasure identifier". If we go refresh the page over here... it works! I just *love* the handling of Subresources in API Platform 3.
