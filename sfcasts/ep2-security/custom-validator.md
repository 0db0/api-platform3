# Custom Validator

Coming soon...

If you need to control behavior around how a field, for example is published is set based on who's logged in, you have two options. First, if you need to prevent certain users from writing to this field entirely, that's what security is for. The easiest option is to use that API property security option that we used earlier above the property. Or you can get fancier like we did and add a dynamic admin call and right group with a context builder. Either way, we're preventing this field from being written entirely. We're determining entirely whether or not this field is allowed to be written. But the second situation is when a field should be a user should be allowed to write to a field. But the data, that's the data that's allowed depends on the user. Like maybe the user can set, maybe a user can set is published to false, but they're not allowed to set it to true unless they are an admin. Let me give you a different example. Currently when you create a dragon treasure, we force you to pass an owner field. We can actually see this in our test. We're gonna fix that in a minute so that you can lead this off and it's set automatically. But right now it's the owner field is allowed and it's actually required.

But who the API client assigns as the owner who they are allowed to assign as the owner depends on who's logged in. For normal users, they can only assign themselves as a user. Here here's the goal. As a normal user, they can only assign themselves as an owner, but if for admins they can assign anyone as an owner and heck, maybe in the future we even get crazier and there are clans of dragons and maybe a user, user a can create a treasure and set the owner to a different user that's in their clan. So the point is it's not just whether or not you can set this field, it actually depends on uh, the val valid data depends on who you're logged in. I forgot to mention earlier, the best way to solve this type of problem is actually validation. We actually solved this in the past up here on the patch operation with security. It's actually this security post de normalized part. That's fine. But I wanna show you what this looks like with validation. And first I'm gonna remind you what this was actually doing. So over here in our test find test patch to update treasure

And let's go ahead and run this. We're on just that test and it currently passes. Now as a reminder, what we're doing here is we were first logging in as the user that owns the treasure and we were updating the user and that was allowed.

Then we were trying to log in as a different user and edit the first user's treasure. And that wasn't allowed. This is a proper use of security. We, since we do not own this treasure, we are not at all allowed to edit it. And that's what this first security line is protecting. It's checking to see if the current dragon treasure object is allowed to be edited by the current user. This last thing here was a little bit trickier. This is actually where we log in as the owner of this treasure, but then we try to change the owner to someone else. And that's also not allowed that this is the situation we're talking about. We shouldn't be allowed to change the owner to someone else as a normal user. This is what I want to handle in validation. And this is currently being fixed by this security posting normalize here where it checks to see what the dragon looks like after the new data is put on it to see if we are still the owner. Anyways, long way of saying I'm going to remove the security posting normalize and to prove what I was just saying is true when we run our tests.

Perfect. It failed online 1 32, which is this one down here. So we're gonna rewrite this security check here in validation and I, the solution's actually a lot nicer. So first because this is gonna fail via validation when we're done, we're gonna change this to assert 4 22. So basically we are allowed to patch to this user, but this is invalid data. We can't set this owner to someone that someone other than ourselves. So to handle this, we're gonna handle validation. We're gonna build our own custom validator. So go to the command line and run make validator, we'll create a new one called is valid owner validator. Now in symphony validators are actually two different classes. So we'll go over and look in source validator first you have this very lightweight class which is gonna be used as the attribute and it just has options on it. And we just have a current message option, which is enough. And actually while I'm here, I'll just kind of change this default message to something a little more helpful for our situation, like you are not allowed to set the owner to this value. The second class is the one that will actually be executed to handle the validation logic and we'll look at that in a second. Fir first, let's use this. So over in dragon Treasure down on the owner property, there we go.

Here we'll add a new attribute and we'll say is valid owner, we're actually referring to that new class that we had right there. And if we wanted to we could.

All right.

All right, so now that we have this, when our object is validated, it's gonna call is valid owner validator and it's gonna pass us the value, which should be the user object and then it's gonna pass us the constraint, which is actually gonna be our is valid owner. So let's do a little bit of cleanup here. I'm gonna take this at var out and replace it with an assert constraint instance of is valid owner. And that's basically once again, just to help my editor. We know symphony's always gonna pass us that value and then here notice that it's checking to see if the value is null or blank and if it does, it does nothing. That's because if the owner property is empty, that's kind of the job of a different validation constraint to catch that. So basically what I mean is what we wanna include on here is a not null constraint. So if they forget to send the owner, this will handle that validation error. And then inside of our code, we don't have to handle that here. We can just return and we know that it's handled elsewhere.

<affirmative>

And then down here, I'm gonna add one more assert that value is an instance of user. So we're gonna be past whatever value is attached to this property. We know that's always gonna be a a user. So basically if for some reason the value is not an instance of user we, it means we mess something up and we put this constraint above uh uh, a property that was unexpected. Cool. Then down here for set parameter, this is a little wild card you can have in the message. We don't need that. And then we're reading constraint error message to get the validation message. So right now we have a functional validator except it's going to fail in all situations so we can at least see if it's being called. So let's run our test and perfect. Okay, 4 22, 200 expected. This is coming from Dragon Resource test line hundred and 10. So basically it's now failing way up here on top because our validation constraints being called and it's always failing. All right, so let's get to work inside of our validator, we're gonna need the currently logged in y the goal is basically to make sure that the owner value is equal to the currently logged in user. So to get the currently logged in user, we'll add a construct method. We'll auto wire, our favorite security class. I'll put private in front of that so it turns into a property.

And then down here I'll say user equals this arrow, security arrow get user. Then I'm gonna add a little like if not user here, we're gonna throw a new logic exception and I'll just put a message inside of there. We could just have a valid validation failure if this happens. But um, really this is a misconfiguration situation. This valid this, uh, we know that you have to be logged in to modify or create users. So if create, uh, dragon treasures, so for somehow we're not logged in, something weird is happening here. Then finally down here, it's pretty simple. If value doesn't equal user, so if the owner's not the user, then we are gonna add that validation failure. Nice. All right, let's try the test and got it. It passes. We're no longer allowed whether we're creating or editing a dragon treasure to set the owner someone that's not us.

And if in the future this got more complex, like that clan idea said earlier, we could handle that in here. For example, we could even add admin users right now. So we can say if this arrow security arrow is granted roll admin, then we could say return. So just like that, admin users are allowed to assign owners to anyone. So thanks to validation, a normal user can now only set themselves as the owner of a treasure when creating or editing, but there is still one big security hole that will allow any user to steal any other user's treasures. Not cool. Let's find out what that is next and fix it.

