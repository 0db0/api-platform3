# Creating a Voter

Coming soon...

Our security logic is getting a little bit crazy, which is not great. We want to keep our security logic simple and centralized. So the way that we centralize security logic in Symfony is via a voter. So let's go ahead and create a voter. So over at the command line we can run `bin/console make:voter` and call this `DragonTreasureVoter`. It's pretty common if you need voters to have one voter class per entity object. This will vote and make decisions about dragon treasures. Thanks to that over in the source security directory. Source security voter we have a new `DragonTreasureVoter`. Now before we talk about this class, I'm going to show you how we use it. In dragon treasure, very simply, we're still going to use the `is_granted()` function. But for the first argument, I'm going to pass `EDIT`, which is just a string I'm making up, you'll see how that's used in the voter. And then we're going to pass this the object. So we don't normally pass `is_granted()` to arguments. But you actually pass it to a string. We normally pass `is_granted()` a role, but you can also pass it a random string like `EDIT`, as long as you have a voter set up for it. We also don't usually pass a second argument `is_granted()`. But again, if you have a voter that is legal. So we're basically saying here is that we're sort of asking the security system, whether or not we're allowed to `EDIT` this `DragonTreasure` object, and we'll have our `DragonTreasureVoter` class is going to make that decision. Let's copy this and paste it down for post you normalize. This is similar. So this is also going to check the same system, make sure that this if we change the owner, whether or not that new owner also has the ability to `EDIT` this `DragonTreasure`. Alright, so here's the deal. Anytime you call `is_granted()` anywhere in the security system, not just an API platform, symphony goes through its list of voters and tries to figure out which voter knows how to make that decision. So when we check for a role, there's a an existing voter class that knows how to handle these. In the case of `EDITs`. There's no core voter that knows how to handle that. We're going to make our `DragonTreasureVoter` handle that. So simply is going to call the supports method every time anybody calls is granted in attribute is going to be the first argument edits and subject is going to be the second argument for us a `DragonTreasure` object. So our job here is to say whether or not we know how to support that type of situation. So by default, it kind of generated voter that handles kind of an edit and also maybe can also check to see if you can view a `DragonTreasure`. We don't need that view at least right now. So I'm going to delete that. I'll delete it down below. I'm also going to change this instance of `DragonTreasure`. I'll retype the end of it and hit tab to add the use statement just to clean that up. So we're basically saying if any someone calls is granted and they pass the string `EDIT` for the attribute and they pass a `DragonTreasure` object, we know how to make that decision. So if we return true from supports, then Symphony calls a voteOnAttribute and that's where we make the actual decision. Oh, and actually, you know what? I'm going to change this to just `EDIT` instead of that post edit. It doesn't really matter, but that makes a little more sense. So down here for voteOnAttribute, we're going to return true if we have access and false if we don't. I'm going to start right now by just returning false. Which means if we have set things up correctly, it's going to call our voter whenever we use a patch request and access will always be denied. And then I'm also going to go down here and remove the case that has to do with the view. All right, let's try this. We're on Symphony `bin/console` make:voter and perfect, we actually see two failing. Both of our patch or tests are failing because both of them are being denied access. That tells me that our voter is being called. All right, so the way this works is the voteOnAttribute is past the attribute. So in our case, that's going to be the string `EDIT`. It's past subject, which we know will be a `DragonTreasure`. And then it's past this token object, which is actually just a wrapper to get the user. So first we're checking to make sure that there actually is a user. Make sure the user is actually authenticated. And then down here, I'm going to say `assert` that `subject` is an instance of `DragonTreasure`. Our method should only ever be called if `supports` return true. So it's not possible for someone to pass as a `subject` that's not a `DragonTreasure`. So mostly writing this just to help my editor with auto completion. It's going to know that `subject` is a `DragonTreasure`. Now that I'm free, we have this switch case statement. We only have one case right now, edit right here is where we're going to put the logic to determine whether or not the current user has access to edit this `DragonTreasure`. So very simply, if `subject`, that's the `DragonTreasure`, arrow get owner equals user, then return true. Otherwise, it will hit the break and it will return false. So we try to test now. We only have one failure. And actually, we need to be careful, we don't have a test for this. But if you'll remember from our API tokens, in order for your if you're using an API token to authenticate in order to be able to edit a user, you need to have this role treasure edits scope. So I don't have a test for it. But that's actually also something we need to test inside of here. And we were testing that we had that before in our `bin/console make:voter` inside of our `Security` bundle. So how do we test roles from a `Voter`? It's actually the same as any service, we're gonna go to the top, create a public function underscore underscore construct. And we can auto wire the `Security` service, the one from `SecurityBundle`. So actually, let me say private `Security` `$security`. Perfect. And then down here, right before we check the owner. And say if not, this arrow is `$security` arrow is granted. Role treasure edit. So if we don't have that role, it doesn't even matter for the owner, we're going to return false. Alright, so the last thing we need to look for in the last test that's failing is testing that an admin can patch to edit a treasure. So because we've already injected the `Security` service, this is really easy. So let's pretend that no matter like an admins can do anything they want in the system. So I can go way up here, even before before the switch case statement, we'll say if this `$this->security->isGranted('ROLE_ADMIN')`, then return true. All right, let's try this thing. We're on the tests. And got it. So our tests are once again passing. And now we have all the logic inside of our `Voter` class. The really great thing about this is that it's super easy to have our permissions here. We just have a very, very simple statement. And then we can actually write all the complex code right in PHP. And of course, you can repeat this process to create a `UserVoter` if you want it to also add some more granular controls on to the user permissions, but I'll leave that up to you. Next, let's add in some security to our `ApiResource` using the `User` entity.
