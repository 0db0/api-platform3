# Filtered Collection

Coming soon...

We've made a pretty fancy API. We've got a couple of sub-resources. We have embedded data, which is readable and writable. This is all really cool, but it does start to make our API more complex, especially when it comes to security. For example, you can no longer see unpublished treasures from the Collection endpoint or the GetSingle endpoint. But you can still see unpublished treasures if you fetch a user and read its `DragonTreasures` field. Watch. Let's write a test for this real quick to expose it. So open our `UserResourceTest`. And down at the bottom, we'll do a public function. `testUnpublishedTreasuresNotReturned()` Inside here, we need to create a user with `user="userFactory"`, colon, colon, `createOne()`. And then `DragonTreasureFactory`. Actually, I don't need that. Actually, I don't need that. That's pretty good. And then `DragonTreasureFactory.createOne()`. And here, we'll say this is going to be `isPublished` false. And let's make sure the owner is set to that user, so we know who the owner of that user is. And then down here, we'll say this arrow browser. And we do need to log in to use the endpoint, but it doesn't matter who we log in as. So I'm going to say `actingAs()`, and we'll say `userFactory.createOne()`. So I'm logging in as someone else. But then I'm going to get `/api/users/` and then `user->getID()`. And down here, we're going to `assertJsonMatches()`. And we'll use a cool thing with the syntax. We can say that the length of the `DragonTreasures` field is zero. Cool. Let's try that. I'll copy the test method name. We will run our test with `--filter=` equals that test method name. And yeah, it fails. So it expected one to be the same as zero. So we are returning that one unpublished item there, and we don't want to. So why? Why is that being returned? Well, an important thing to understand about these query extension interfaces is that these are used for the original query. So `queryCollectionExtensionInterface`, that applies to the collection endpoint only when we're querying for a collection of treasures. But when you use a user endpoint, what it's first going to do is query for that user. And once it's queried for that user, in order to get this `DragonTreasure` here, it doesn't make another query for `DragonTreasures`. Instead, if you open the source entity user class, all it does is call `getDragonTreasures()`. So queries for the user, it calls `getDragonTreasures()`, and whatever this returns is going to be what is set onto that field. And since this is going to return all `DragonTreasures`, that's what we get, including the unpublished ones. So the way to fix this is to add a new method that only returns the unpublished ones. So `public function getPublishedDragonTreasures(): Collection`. And inside, we can just kind of get fancy here. We can say `this->DragonTreasures`, and we can use a filter function. And then pass that a callback. That will get a `DragonTreasure` `treasure` argument. And inside, we can say `return treasure->getIsPublished()`. So that's just a really fancy way to loop over all the `DragonTreasures` and return a new collection that only has the published ones. By the way, one downside to this approach is that if a user has 100 `DragonTreasures`, but only 10 of them are published, internally, Doctrine is first going to need to query for all 100 treasures simply to return only 10 of them. So if you have possibly have large collections of `DragonTreasures`, this can be a performance problem. In our Doctrine tutorial, we talk about using something called the criteria system. Criteria like this. And that's a way where you can actually create, do the same thing, but use an efficient query to only return the unpublished ones. Anyways, just creating this getter method is not enough. This is not going to be part of our API. What we can do now is we can go up to the `DragonTreasures` property. Here we go. And it's currently readable and writable. Let's make that property only writable. But then down here on our new method, we will say `groups user:read` will make this writable. And then we'll control its name with `SerializedName('dragonTreasures')`. So we should still get that field back, but it's not going to be calling this method. All right. Try the test. It explodes because I have a syntax error. All right. Try the test. All right. Try the test. And we're green. All right, everyone. Thank you for joining me in this gigantic, cool journey with API platform and security. So this is pretty complicated because I wanted you to be able to solve real complex security use cases. In the next tutorial, we're going to look at even more custom and cool things you can do with the API platform, including how to use classes for API resources that are not entities. And we'll see how that up front can cause a little bit more work, but I can also make your API easier to control and your code easier to read. Our friends, if there's something that we haven't covered yet that you want to make sure is covered in future tutorial, let us know. As always, we're here for you in the comment section. See ya.
