# Unit Of Work Validator

Coming soon...

We still have a big hole when it comes to making sure that treasures aren't assigned to the wrong owners. What we did just cover the main case. If you make a post or a put request to a treasure endpoint, thanks to our new validation, we make sure you assign the owner to yourself unless you're an admin. But we also made it possible in our API when we are posting or patching to a user endpoint to send a dragon treasure's field. This unfortunately means that we are allowed to steal another user's treasure simply by modifying our own user and setting dragon treasures to the I R I of some other dragons <affirmative> treasure. So the simplest solution would be to just not make this field writeable. So inside of our user entity on Dragon Treasures, we could make this readable, but just remove the writeable part that would force the users to use the API slash treasures endpoints to manage all of their treasures instead of kind of doing it via this fancy feel. If you do want this, you can, but it is a tricky problem to solve if you think about putting some sort of validation constraint on this property. The problem is that by the time validation runs, the treasures sent over in the J S O N have already been set on this Dragon Treasure's property

And that means that those existing Dragon treasures their users have already been updated. As a reminder, that happens because the serializer will call add Dragon treasure with the new Dragon treasure and then we call set owner to the new owner. So by the time validation runs, it's gonna look like we are the owner of the treasure, even though we originally weren't. Now API platform does have this idea of previous data. There's a way INAP platform to get the previous data. We talked about this a little bit with the security attribute. When you use, uh, you know what, let's not do that. A API platform clones the data before it serialize DC realizes the new data onto it. And so it is possible to get the, what the, we're updating a user to get what the user originally looked like before the data was Sealy. Unfortunately, that clone is shallow, meaning that it doesn't take a proper clone of what the original Dragon treasures look like. That needs a better explanation. So one solution might be no. So to fix this, if we wanna keep our Dragon treasures field writeable but not allow treasures to be stolen,

We're gonna need validation but kind of validation with some special magic. We're gonna use something called Doctrine's unit of work to ask doctrine for the original data for the Dragon treasures before they were updated. So let's start by creating a test to expose this bug. So on set of tests functional, we're gonna do this inside of the reus resource test and I'll copy our existing, our previous test and let's call this test. Treasures cannot be stolen and we'll need a user fact. A user. Let's create another user, user factory calling, calling Create one. And then we need a Dragon Treasure that we're gonna try to steal. So we'll set that to Dragon Treasure Factory calling, calling create one and we're gonna set the owner to the other user. Perfect. So then here's the idea. We're gonna log in as ourselves, we're log in as user, we're gonna update ourselves, which is totally allowed. And then for the json, sure, maybe we'll send the username still, it doesn't really matter. Then we're gonna send a Dragon treasures field set to slash API slash treasures slash dragon treasure arrow get id. Perfect. And we're gonna start down here that this should be a 4 22. We want this to be a validation error not allowed. So I'll copy that method name.

Right now I'm expecting that this will fail, so I'll run dash dash filter equals that method name,

Oops.

And yep, it fails. Current status code is 200, meaning we are allowing Dragon treasures to be stolen lame. So we are gonna solve this with a custom validator. So just like before we'll say Bin Console, make validator and I'm gonna call this Treasures Allowed Owner Change. Perfect and created those two classes. And then to use this, we're actually gonna put this right above the Dragon Treasure's property. This is the one that we're checking to see whether it's valid or not. So right there we'll say Treasures Allowed Owner change. All right, and then now over in our source validator directory, let's open up the validator class and we'll just do some basic cleanup in here. Just like before, I'm gonna use the nice assert function to assert that constraint is an instance of treasures allowed owner change our attribute class. And then down here I'm going to assert that value is an instance of collection from doctrine. From doctrine. So we know that this is gonna be used above a collection property. So this is gonna be some sort of collection of dragon treasures. So just making sure we put it in the right spot. Okay, so at this point this is gonna be the collection of Dragon treasures after they've been modified, we need to ask doctrine what that data looked like, what each dragon treasure looked like before, like when it was originally queried from the database. In order to do that, we need to grab an internal object and doctrine called the unit of work. So to get that at the top at a constructor

And we're going to inject entity manager, interface entity manager, and we'll make that a private property. And now down here we can grab a unit of work with unit of work equals this arrow, entity manager arrow get unit of work. This is a special powerful internal object that keeps track of how objects are changing internally. So now we can for each over value, cuz we know that will be a collection of dragon treasure. So value as dragon treasure inside here. Again, just mostly just to help my editor, I'm gonna insert that dragon treasure is an instance of dragon treasure. And below let's get the original data. So to do that you can say original data equals unit of work arrow. Get original entity data and you can pass it that dragon treasure. You'll see in a second that's actually gonna return an array of the raw data the way it looked like originally in the database. So down here let's DD dragon treasure and original data so we can kind of see what that looks like. All right, run that test again. Let's see. Yes, it hit it. So awesome. So we can see the first dragon treasure is what we expect.

And you can see that it's owner has ID one, it's not super obvious from our test, but the way our test set is set up is this is gonna be ID one and this is gonna be ID two. So you can see that the owner has, the owner was originally set to ID two, but yeah, we've successfully stolen that dragon treasure at this moment. But down below this we have the array of original data, including the owner with ID two. Or I can also read the owner underscore ID directly. That makes us dangerous. So now back over inside of our validator, we can say original owner ID equals original data and I'll use that owner ID key. And then the new owner id, just to make this really clear is dragon treasure, arrow get owner, arrow, get id. And if these don't match each other, we have a problem. So if now first thing I check is if we don't have an original owner id, that means we're actually creating a new dragon treasure. And so we don't have a problem with that. There's no stealing that we need to check. So that's okay. So if where is no original owner ID or the original owner ID is equal to the new owner id, we're good. So I'm actually going to do a return statement there else done here. This is where we have a problem. So I'm gonna copy this

Violation builder up here. We don't need the set parameter part and we will add the air and actually haven't customized that error message yet. So let's go over here into the constraint class and we'll put a message class, give that a default message. Our team, let's try that spin back over, run the test and got it. It passes. Dragon treasure stealing is now no longer a concern and though I didn't do it here, you could very easily also inject the security class and you could allow changing the owner if the current user is an admin if you want to. All right, next, when we create a dragon treasure, we currently need to always send the owner. Let's finally make that optional. If we don't pass the owner, we'll set it to the currently authenticated user. To do this, we need to hook into API platform's saving process. One more time.

