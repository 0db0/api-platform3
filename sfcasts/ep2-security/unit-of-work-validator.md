# Unit Of Work Validator

Coming soon...

We still have a big hole when it comes to making sure that Treasures aren't assigned to the wrong owners. Well, we did just cover the main case. If you make a POST or a PUT request to a Treasure endpoint, thanks to our new validation, we make sure you assign the owner to yourself, unless you're an admin. But, we also made it possible in our API, when we are posting or patching to a user endpoint, to send a `DragonTreasures` field. This, unfortunately, means that we are allowed to steal another user's Treasure, simply by modifying our own user and setting `DragonTreasures` to the IRI of some other Dragon's Treasure. So, the simplest solution would be to just not make this field writable. So, inside of our User entity on `DragonTreasures`, we can make this readable, but just remove the writable part. That would force the users to use the API's slash Treasures endpoints to manage all of their Treasures, instead of doing it via this fancy field. If you do want this, you can, but it is a tricky problem to solve. If you think about putting some sort of validation constraint on this property, the problem is that by the time validation runs, the Treasures sent over in the JSON have already been set on this `DragonTreasures` property. That means that those existing Dragon Treasures, their users have already been updated. As a reminder, that happens because the serializer will call `addDragonTreasure` with the new Dragon Treasure, and then we call `setOwner` to the new owner. So, by the time validation runs, it's going to look like we're the owner of the Treasure, even though we originally weren't. Now, API Platform does have this idea of `previous_data`. There is a way in API Platform to get the previous data. We talked about this a little bit with the security attribute. When you use... You know what, let's not do that. API Platform clones the data before it deserializes the new data onto it. And so, it is possible to get what the... When you're updating a user, to get what the user originally looked like before the data was serialized. Unfortunately, that clone is shallow, meaning that it doesn't take a proper clone of what the original `DragonTreasures` look like. That needs a better explanation. So, one solution might be... Below is an audio to text transcription from Whisper in for a Symfony & API Platform tutorial screencast. No. So, to fix this, if we want to keep our `DragonTreasures` field writable, but not allow Treasures to be stolen, we're going to need validation, but validation with some special magic. We're going to use something called Doctrine's Unit of Work to ask Doctrine for the original data for the `DragonTreasures` before they were updated. So, let's start by creating a test to expose this bug. So, inside of `tests/Functional`, we're going to do this inside of the `UserResourceTest`. And I'll copy our existing... Our previous test. Let's call this `testTreasuresCannotBeStolen`. And we'll need a user. Let's create another user. `UserFactory::createOne()`. And then we need a `DragonTreasure` that we're going to try to steal. So, we'll set that to `DragonTreasureFactory::createOne(['owner' => $otherUser]);`. Perfect. So, then here's the idea. We're going to log in as ourselves. We're going to log in as user. We're going to update ourselves, which is totally allowed. And then for the JSON, sure, maybe we'll send the username still. It doesn't really matter. Then we're going to send a `DragonTreasures` field set to `/api/treasures/` . `$dragonTreasure->getId()`. Perfect. And we're going to assert down here that this should be a 422. We want this to be a validation error, not allowed. So, I'll copy that method name. Right now, I'm expecting that this will fail. So, I'll run `dash --filter=` that method name. Oops. And, yep, it fails. Current status code is 200, meaning we are allowing `DragonTreasures` to be stolen. Lame. So, we are going to solve this with a custom validator. So, just like before, we'll say `bin/console make:validator`. And I'm going to call this `TreasuresAllowedOwnerChange`. Perfect. And create those two classes. And then to use this, we're actually going to put this right above the `DragonTreasures` property. This is the one that we're checking to see whether it's valid or not. So, right there, we'll say `TreasuresAllowedOwnerChange`. All right. And then now, over in our `src/Validator` directory, let's open up the validator class. And we'll just do some basic cleanup in here. Just like before, I'm going to use the nice `assert()` function to assert that `constraint` is an instance of `TreasuresAllowedOwnerChange`. So, I'm going to use that in our attribute class. And then down here, I'm going to assert that `value` is an instance of `Collection` from Doctrine. So, we know that this is going to be used above a collection property. So, this is going to be some sort of collection of `DragonTreasures`. So, just making sure we put it in the right spot. Okay. So, at this point, this is going to be the collection of `DragonTreasures` after they've been modified. We need to ask Doctrine what that data looked like, what each `DragonTreasure` looked like before, when it was originally queried from the database. In order to do that, we need to grab an internal object in Doctrine called the `unit of work`. So, to get that, at the top, add a constructor. And we're going to inject `EntityManagerInterface $entityManager`. And we'll make that a private property. And then down here, we can grab a `unit of work` with `unitOfWork = $this->entityManager->getUnitOfWork()`. This is a special powerful internal object that keeps track of how objects are changing internally. So, now we can `foreach` over `value` because we know that will be a collection of `DragonTreasures`. So, `value as $dragonTreasure`. Inside here, again, just mostly just to help my editor, I'm going to assert that `$dragonTreasure` is an instance of `DragonTreasure`. And below, let's get the original data. So, to do that, you can say `originalData = $unitOfWork->getOriginalEntityData($dragonTreasure)`. You'll see in a second, that's actually going to return an array of the raw data the way it looked like originally in the database. So, down here, let's `DD($dragonTreasure, $originalData)`. So, we can kind of see what that looks like. All right, run that test again. Let's see. Yes, it hit it. So, awesome. So, we can see the first `DragonTreasure` is what we expect. And you can see that its owner has ID one. It's not super obvious from our test, but the way our test set is set up is this is going to be ID one. This is going to be ID two. So, you can see that the owner was originally set to ID two, but yeah, we've successfully stolen that `DragonTreasure` at this moment. But down below this, we have the array of original data, including the owner with ID two. Or we can also read the `owner_id` directly. That makes us dangerous. So, now back over inside of our validator, we can say `originalOwnerId` equals `originalData['owner_id']`. And then the new `ownerId`, just to make this really clear, is `DragonTreasure->getOwner()->getId()`. And if these don't match each other, we have a problem. So, if... Now, the first thing I'm going to check is if we don't have an `originalOwnerId`, that means we're actually creating a new `DragonTreasure`. And so, we don't have a problem with that. There's no stealing that we need to check, so that's okay. So, if there is no `originalOwnerId`, or the `originalOwnerId` is equal to the `newOwnerId`, we're good. So, I'm actually going to do a return statement there. Else down here, this is where we have a problem. So, I'm going to copy this `violationBuilder` up here. We don't need the `setParameter` part. And we will add the error. And actually, I haven't customized that error message yet. So, let's go over here, into the `constraint` class. And we'll put a `message` class, give that a default message. All right, team, let's try that. Spin back over. Run the test. And got it. It passes. `DragonTreasure` stealing is now no longer a concern. And though I didn't do it here, you could very easily also inject this `security` class. And you could allow changing the owner if the current user is an admin, if you want to. All right, next. When we create a `DragonTreasure`, we currently need to always send the owner. Let's finally make that optional. If we don't pass the owner, we'll set it to the currently authenticated user. To do this, we need to hook into API platform's saving process one more time.
