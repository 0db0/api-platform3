# Test Setup

Coming soon...

Our API is getting more and more complex and manually testing our API is not a great long-term plan. So let's install some tools to get a killer test set up. Step one at your terminal run `composer require test`. This is a flex alias for a package called `symfony/test-pack`. Remember, packs are kind of shortcut packages that actually install a bunch of packages. So for example, when this finishes and we check out `composer.json`, you can see down in `require-dev` this added PHPUnit itself as well as a few other tools from Symfony to help testing it Also executed a recipe which added a number of files. We have a `phpunit.xml.dist` file. To get us started, we have a `tests/` directory, a `env.test` file for test specific environment variables and even a little `bin/phpunit` executable shortcut that we'll use to run our tests. Alright, so obviously Symfony has tools for testing and these can definitely be used to test an API. And API platform even has their own tools built on top of those to make testing an API even easier. However, we are going to use a tool that I love

That's built on top of Symfony's tools called Browser because it's just super fun to use. Browser gives us a nice fluid interface that can be used for testing web applications like you see here, or testing APIs. It can also can be used to um, test, uh, JavaScript. So let's get this guy install, I'll copy the `composer require` line, we'll spin back over, run that. And while that's running it's optional, but there's one other little extension class that you can add to `phpunit.xml.dist`. Add it down here on the bottom. And what this is going to do is add some extra features like when tests fail, it will automatically save the last response that happened. And if you're using JavaScript testing, it'll actually take screenshots for you. You'll see this in terms of the API in a minute. All right, so we are ready. Let's create our first test in the `tests/` directory it doesn't really matter how you organize things in here, but I'm going to create a `Functional/` directory because what we're going to be doing is making functional tests to our api. We're actually going to be taking an API client making GET and POST requests and then asserting that we have the correct output. I'm going to create a class called `DragonTreasureResourceTest.php` `DragonTreasureResourceTest`. And then kind of like a normal test, we're going to make this extend not `TestCase` from PHPUnit, but `KernelTestCase` that extends `TestCase`. But this gives us access to Symfony's container, which we're going to need. All right, so let's start simple. Let's just test the GET collection endpoint and make sure that we get back the data that we expect to use a browser. Right now this is just a normal PHPUnit test To use that browser library. We're going to add a trait called `use HasBrowser`, and then down here I'll say `public function`. How about `testGetCollectionOfTreasures()`? This method will return `void` using browser is dead simple thanks to that trait. We have a new `browser()` variable and then we can make GET, POST, PATCH whatever request we want. So let's make a GET request to `/api/treasures` and then just to see what that looks like, we can use this nifty little `->dump()` function. How cool is that? All right, let's try it. So to execute our test, we can run `vendor/bin/phpunit`. That works just fine. There's also a little shortcut that Symfony added that the recipe added which is `bin/phpunit`.

So when we run that, ooh, let's see, you can see this. The `dump()` did happen, but look it, it says SQL State connection to server port 5432 failed. It's not talking to our database. Ah, remember how our database is working? Our database is running via Docker and then because we're using the Symfony web server. When we use our browser over here, the Symfony web server is detecting Docker and setting the `DATABASE_URL` environment variable for us. So that's why our web, our API is talking to able to talk to the Docker database When we run commands in the command line that need to talk to the database, we've been running things like `symfony console make:migration` because when we execute things through `symfony`, it adds the `DATABASE_URL` environment variable that talks to Docker. So when we run our test and we can't just run `php bin/phpunit`, we need to run `symfony php bin/phpunit`. It's the same thing, but it's going to allow `symfony` to add that `DATABASE_URL` environment variable. And now let's see, we see a dump. Let's go to the top. Okay, better it's talking to the database, but it says

Database `app_test` does not exist. Interesting. So let's take a little look here. If you open your `config/packages/doctrine.yaml` file

And you scroll down, there's a `when@test` section that's added automatically. This is really cool. So when we're in the `test` environment, there's a little config here called `dbname_suffix`. So it's automatically going to take whatever database name you have configured normally and it's going to add `_test` to it. This next part here is actually specific to a library called ParaTest where you can run your tests in parallel. That's, we're not doing that, so that's just an empty string for us. So anyways, that's how we end up with an `_test` at the end of our database name. And we want that. We don't want our development environment and our test environment to use the same database because it just gets annoying that they're running over each other's data. By the way, before we fix that, I do want to mention if you're not using the `symfony` Binary and Docker setup and you're configuring your database manually, be aware that in the test environment you're, if you have a `.env.local` file, it is not read. The test environment is special. It skips reading the `.env.local` file and only reads the `.env.test` file.

So if you do have some database specific configuration that you want, don't wanna commit to your repository, you can create a `.env.test.local` file and configure your `DATABASE_URL` there. There. All right. Anyways, in the `test` environment, we're missing our database. So we could easily fix this by running `symfony console doctrine:database:create --env=test`. But we are not going to do that because that's way too much work. Instead we're going to use one more trait inside of our test, say `use ResetDatabase`. This comes from Foundry, the library where that gives us all of our test data via the factories. And what `ResetDatabase` does is it automatically makes sure that the database is cleared before every test. So if you have two tests, your second test isn't going to mess up because it has data from the first test. It's also going to create the database automatically for us. Check this out. Run `symfony bin/phpunit` again and check out that dump. That is our response. The beautiful JSON-LD is coming back. We don't have any items inside of there yet, but it's working. And by the way, I just want to point out that right now when we make this GET request, this is not passing the `Accept` header

That says we want, as a reminder, when we try out, when you use Swagger over here, it actually passes an `Accept` header that advertises that we want `application/ld+json`. We could have that here. I'm just pointing out we are not. The fact that we're, we are getting back JSON-LD is because that's the default format in our API. Anyways, next, let's actually write this test and do some assertions.
