# Custom Field

Coming soon...

Let's do something fun. I want to create a totally custom, crazy new field to `DragonTreasure`, a `DragonTreasure` API that doesn't exist in our class at all. This is something else that you can do with a custom normalizer. And since we already have one set up, I thought we'd use it to also add a completely custom field. So, go to `DragonTreasureResourceTest`. And on `testOwnerCanSeeIsPublishedAndIsMineFields()`: void we can see `$isPublished` field. Let's also add `$isPublished` and `$isMine` fields. This is really silly, but literally if we own a `DragonTreasure`, we're going to add a new Boolean property called `$isMine` set to true. So down here at the bottom, we'll say `$isMine` and we'll expect it to be true. So let me copy that method name. We'll spin over and run our test with `assertJsonMatches('isMine', true)` and perfect. It's null because it's not there and we expected it to be true. So how can we add this? Now that we've gone through all the pain to get this normalizer set up just right, it's pretty easy. So what we're going to do is we're going to allow the normalizer system to run. That is going to return to us the normalized data. Then if we want to, between that and the `return` statement, we can just mess with it. So I'm going to copy this if statement from up here. I could be more clever and reuse code here, but not too worried about that. So if we're a `DragonTreasure` and we own this `DragonTreasure`, we will say `$normalized`, and we'll say `isMine` equals true. That's it. When we run our test, it passes. Now a practical downside to this is that totally custom fields like this are not going to be something that's documented in our API. Our API documentation have no idea that something like that exists. If you do need a super duper custom field like this that requires some service logic to figure out its value, and you need it to be documented in your API, you could also solve this with a custom data provider and a non-persisted property on your class. So we could add like a new property to our `DragonTreasure` called `isMine`, and then a custom provider, `DragonTreasureFactory::createMany()`, we could populate that. Now we have not talked about providers yet. That's how data is loaded, and that's something that we're going to talk about a little bit more later, but mostly in a future tutorial. I just wanted to mention that now if you're wondering how you could get a custom field that is also documented. All right. Next, if a user is allowed to edit something, but there are certain changes to the data that they are not allowed to make, how do we handle that? Well, that's where security meets validation.
