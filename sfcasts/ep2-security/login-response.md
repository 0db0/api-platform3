# Login Response

If you refresh this page and check the web debug toolbar, you can see that we're *not* currently logged in. Let's try using a real email and password. We can cheat by just clicking this email and password here. This exists in our app fixtures, so it *should* work when we log in. And... okay... the boxes disappear, but nothing else happens. We'll improve that in a minute, but for now, refresh the page and look at the web debug toolbar again. We're *authenticated*. Just by making a successful AJAX request to that login endpoint, that was enough to create this session and keep us logged in. Even better, if we started making requests to our API from our JavaScript, those requests would be authenticated too. That's right! We don't need a fancy API token system where we attach a token to every request. We can just make a request and the magic of cookies will automatically attach it to every request we make so they're authenticated.

Okay, logging in *worked*, but nothing happened on the page. So... what should we return after authentication? What would be helpful to return so users will see something different here? Once again, it doesn't really matter. If you're writing this for your own JavaScript, you should do whatever is useful for your app. We're currently returning the `user` IRI, but we *could*, if we wanted to, return the entire `user` object as `JSON`. *But* there's one tiny problem with that. It's not super *restful*. This is one of those "rest purity" things. Every different URL that you have represents a different resource. This represents the *collection* of resources, and this URL here represents a *single* `user` resource. And if you have a different URL, that's understood to be a *different* resource. The *point* is that, in a perfect world, you would just return a `user` resource from a single URL instead of having five *different* `endpoints` where you can get `user` resources. If we return the `User` JSON from this endpoint, we're basically creating a new API resource that is *also* the user. In fact, *anything* we return from this endpoint, from a restful point of view, becomes a new resource in our API. This isn't *super* important, but it's not the most *restful* thing to do. You should do whatever you want, but this is good to keep in mind.

To try to be helpful to our frontend *and* try to follow the spec, I have another idea. What if we return *nothing* from this endpoint, but sneak in the `user` IRI onto the `Location` header of the response so that our frontend knows *who* just logged in? Let me show you. First, instead of returning the User ID, we're going to return the IRI, which will look something like `/api/user/` and then the `$user` ID. But I don't want to hard code that because we might change that in the future. I'd rather have API Platform *generate* that *for* me. How can we do that?

Fortunately, API Platform gives us an autowireable service. Before the optional argument, add a new argument typehinted with `IriConverterInterface` and call it `$iriConverter`. Then, down here, we're going to `return new Response()` (the one from HttpFoundation) with *no* content and a `204` status code. The `204` means it was "successful, but there's no content to return". We'll also pass a `Location` header set to `$iriConverter->getIriFromResource()`, so you can get the resource from an IRI or the IRI string from the resource - the resource being your object.Finally, we'll pass this `$user`. How nice is that?

Now that we're returning this, the *next* question is: How can we use this in JavaScript? Ideally, after we log in, we want to automatically show some user information over here on the right. This area is actually being built by another Vue file called `TreasureConnectApp.vue`. I won't go into the details, but basically, as long as it has user information, it's going to print it out here. *And* `LoginForm.vue` is *already* set up to pass that user information to `TreasureConnectApp.vue`. Down at the bottom, after a successful authentication, you can see that *this* is where we clear the `email` and `password` state. That's what clears these boxes after we log in. Then, if we emit an event called `user-authenticated` and pass it the `userIri`, our `TreasureConnectApp.vue` file is *already* set up to listen to this as well. It will make an AJAX request to `userIri`, get that JSON back, and populate its own data. Don't worry about the details of the Vue app. The *point* is that all we need to do is grab the IRI from the `Location` header here, emit this event, and everything else should be connected.

To *read* the header, we can say `const userIri = response.headers.get('Location')`. I'll also uncomment this so we can `emit` it. This should be good, so let's move over and refresh. The first thing I want you to notice is that we're still logged in, but our page doesn't actually *know* we're logged in. We're going to fix that in a second. Go ahead and log in again using our valid email and password, and... *beautiful*! We made the `POST` request here that returned the IRI. Then our JavaScript made a second request *to* that IRI to get the user information, which it displayed over here.

Next: Let's talk about what it means to log *out* of an API. Then, I'll show you a simple way of telling your JavaScript *who* is logged in on page load. Because, right now, even though we're logged in, as soon as I refresh, our JavaScript thinks we're logged out. Let's fix that.
