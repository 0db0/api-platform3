# Scopes

Coming soon...

Our API tokens all have an array of scopes, though we're not using them yet. The idea is that when a token is created, you can select, you can select which permissions it has, like maybe a token gives, the permission to create new treasures but not edit existing treasures. So what the idea is, is that maybe we can map whatever scopes a token has to roles in Symfony so then we can deny or allow access A little bit more granular. Right now in our `ApiTokenHandler`, we're just returning the user and we're logging in fully as that user. And then that user is just getting whatever roles it has on its `User` object. But now I'm going to use the scopes as the roles. So how can we do that? Well, it's actually a little bit tricky. Our `access_token` security system, the actual code behind that I'll hit Shift + Shift is called `AccessTokenAuthenticator`. So for example, this is actually the thing that grabs the token off the request and actually calls our access token, `getUserBadgeFrom($accessToken)`. The tricky thing here is that ultimately down here in this `createToken()`, this is actually where it figures out what roles the currently authenticated user should have. And you can see no matter what it always calls, `->getUser()->getRoles()` and we don't really have a lot of control over this.

So we could create a custom authenticator so that we could implement our own `createToken()` method and do it manually. But man, that's a lot of work just for that one small detail. So instead I think we can kind of cheat. So check this out, in `User`.

Scroll

Up to the top where we have our properties and let's add a new property. It's going to be a `private ?array` called `$accessTokenScopes`. And we'll initialize it to `null`. Notice this is not a persisted column on purpose. This is just a temporary column that will temporarily store the scopes that this user should have. If we log in via an access token, I'll show you how it's used. So down at the bottom I'm going to create another public method called `markAsTokenAuthenticated()` with an `array $scopes` argument. This is something that we're going to call during authentication inside of it, we're just going to say `$this->accessTokenScopes = $scopes`. Easy peasy. Now here's where things get interesting. I'm going to search for the `getRoles()` method. So we know that no matter what, this is what's going to be called after a user authenticates and whatever roles they have in the database plus whatever, plus `ROLE_USER`, that's what they're going to have. So we need to kind of sneak our scopes into that a little bit.

Daddy.

So we're going to rearrange this method a little bit. So first I'll say if that `$accessTokenScopes` property is `null`, that means we're logging in like a normal user. So what we're going to do in that case is we'll set `$roles` to `$this->roles`, so we get all the `$roles` that are on the user. Then I'm also going to add an extra role here called `ROLE_FULL_USER` that we're going to talk about in a minute. Now else if we did log in via an access token, we'll say `$roles = $this->accessTokenRoles`, and we'll still make sure that every role has `ROLE_USER`. We always have `ROLE_USER`. It's just a convenient role just to check to see if you're logged in at all. All right, thanks to this setup over in our `ApiTokenHandler`. Right before we return the `UserBadge`, we can say `$token->getOwnedBy()->markAsTokenAuthenticated()`, and then pass it. `$token->getScopes()`. All right, let's try that back over here in Api Platform. I'm already like log, I'm already logged in with my API token. I'm just going to re-execute this request down here you can see my `Authorization` header. Then I'll click to open the profiler for that request. Head down to "Security" and Okay, good.

Perfect. Look, we are logged in as that user, but we have `ROLE_USER` and then `ROLE_USER_EDIT` and `ROLE_TREASURE_CREATE` the two scopes from that token. But if we were to actually log in through the full mechanism, instead of having these scopes, we would have whatever roles the user normally has, plus this `ROLE_FULL_USER`. Now we're not actually using any of these roles to protect any endpoints yet. We're going to do that in a little while and we're going to do that for example, by, you know, protecting the `POST` treasures endpoint, making sure we require this role. But we want to make sure that if a user is logged in via the normal method, that they still are able to create a treasure even though they don't have this role. So that's where this `ROLE_FULL_USER` comes in handy. So I'm going to open `config/packages/security.yaml` and anywhere inside of here I'm going to create a `role_hierarchy`. And I'm also going to spell that word correctly. And what we're going to say here is `ROLE_FULL_USER`. If you're logged in as a full user role, we're actually going to give you all of the possible scopes that a token has. So I'm going to copy these three tokens here. So `ROLE_USER_EDIT`, `ROLE_TREASURE_CREATE`

And `ROLE_TREASURE_EDIT`. Yeah, it's kind, we do have to be careful to make sure that if we add more scopes here, we add them over here. So it means if we protect something in our system, we require `ROLE_USER_EDIT` and if a user is logged in as the full user, they will get this automatically. Thanks to `role_hierarchy`. All right, team, we're not going to try this yet, but we'll see it in a few minutes. All right, team, we are done with authentication. Woo. So next, let's start talking. Let's start into authorization by learning how to lock down certain operations so that only certain users can access them.
