# Security

Coming soon...

All right, so we've just talked a lot about authentication. That's the way that you tell the API who you are. Now we're gonna turn to authorization, which is where we deny access to certain operations and other stuff based on who you are. So there's multiple ways to do this. The simplest ways actually in config packages, security di yamal, just like normal symphony security down here, there's this access control section. If you wanna lock down a specific URL pattern by a specific roll, use access control, this would be a great way to, for example, lock down your entire api. So in normal web apps, I do use access control somewhat, but most of the time I put my authorization rules in my controllers. But of course, with the API platform, we don't have controllers. All we have are our API resource classes, like Dragon Treasure. So instead of putting our roles and controllers, we're gonna basically attach them to our operations. For example, let's make the post request to create a new dragon treasure, require the user to be authenticated. So we do that is via this cool little security option. And then we set that to a string

And inside we can say is underscore granted.

And then double quotes and then roll, treasure create. Now really we could have just used roll user here, I just want to make check to make sure that the user is logged in. But as a reminder, we have a little system where if you use API token for authentication, you can choose different scopes. And we have a scope called scope treasure edit. So we actually wanna check for this specific role. Also as a reminder, inside security that YAML via rural hierarchy, if you log in via our actual login form, you get roll full user to automatically get roll treasure edit. So we're using this rural treasure create here, which you'll either have if you logged in as a real user or if you're using an API token that has that scope. All right, let's try that, see what happens. So make sure we're logged out. So I'm gonna refresh the page here. You can see I'm not logged down there and we don't have any bear token. Let's try the post endpoint. Let try it out. And I'm just going to, sure, we'll just hit execute on that. And perfect 4 0 1 status code and a type hydra error.

So this security key over here is actually an expression using symphony's expression language. And you can actually get a bit fancy with it though. We're gonna try to keep things simple. And later we'll learn how to offload complex rules to voters. So let's a couple other rules in here. So put and patch are both edits. And we're actually, and these are interesting because not only do we need to be logged in, we probably need to be the owner of this dragon treasure and able to be edited. We don't want people to edit other people's dragon treasures. We're gonna worry about that ownership part later. But for now, let's at least put security, we'll say is granted. And here we'll say roll treasure edit. Once again using that scope from there, I'll copy that and we'll duplicate down here for the patch method. And then earlier we remove, we removed the delete operation. Let's actually add that back now and we'll say a security option for roll underscore admin. If we decided later to add a scope that allowed you to delete treasures, we could change and use roll treasure. Delete right here. All right, so let's make sure that works. I'm going to use the GI collection endpoint.

Oops, try that out. This still does not require authentication, so that works just fine. And we have a treasure with ID one. So I'll close up this endpoint and we'll open up the put endpoint, hit try it out, one, execute and perfect. We get the 4 0 1 there as well. So adding the security to the individual operations is probably the most common thing to do. But you can also add it to the API resource level itself to apply to the entire class. Like for example, for user, we probably want pretty much all of our operations to require authentication except for the post to create, cuz that's actually how you register. So up here we can say security roll user just to just to check for logged in. And because we have a sub resource here, and this also allows us to fetch a user, we need to make sure you put security there. So keep track of that if you have sub resources that you're including it in both spots if you need to.

So

That's cool. But as I mentioned, we actually don't wanna require authentication for the post request. So to give us that flexibility, I'm gonna go up to a first a API resource and we're gonna add

The

Operations option to this. And real quick, we're gonna put all the normal operations, new, get new, get collection, new post new put, new patch, and new delete. Now that we have those, we can customize them. So the first thing is for post. This is the one that we want to be public. So I'll say security is granted when you use a special kind of fake rule here called public access. So this is going to override the one that we're passing on the resource level. So it should allow this one to have public access. Also, while we're here for the put endpoint, we once again have an API token called roll User Edit. So we're gonna be a little more powerful than roll user. We want you to actually have that roll. And I'll repeat that down here for the patch endpoint. All right, so let's try this. I'm gonna refresh the whole page. And what I'm interested in is the post user endpoint. So I'm not authenticated, let's hit try it out. I'll just leave that default data, hit execute and awesome 2 0 1. So we did allow access on that. And as a reminder, if you ever wanna see the decisions that were made, you can always open the profiler for that request and go down to security,

Go to access decision. And you can see here, there's, in this case, there's only one decision made. It was for our public access, and that was allowed. All right, next, our API is getting complex and it's only going to get more complex. So it's time to stop testing our endpoints manually via swagger and start testing them with automated tests.