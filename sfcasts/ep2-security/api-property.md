# Api Property

Coming soon...

We control which fields are readable and writable inside of our code via the `serialization groups`. But what if you have a field that should be included in the API ONLY for certain users? It's not something we can do out of the box with groups. For example, find the `isPublished` field and let's expose this to the groups `treasure:read` and `treasure:write` to make that part of our API. Now if we spin over and try the tests, this makes one test fail. Our `GET` collection of treasures because it sees that there is now a new `isPublished` field being returned that wasn't there a second ago. So the idea is that we only want this field to be returned for admin users or owners of the dragon treasure. How can we do this? Well say hello to a new attribute that you can use above your properties called `ApiProperty`. There is actually a bunch of things that you can do with this including a description that helps with your documentation and also a whole bunch of more advanced things inside of here. But there's even one called `readable` so you'd say `readable: false`. This is kind of the serialization groups are sort of making this part of our API and then we're saying but it's not readable so then if you try the tests I'll actually do that actually does make the test pass it hides that field. Though it's not what we want. One of these super cool options inside of `ApiProperty` is `security`. So for example we can set this to `is_granted("ROLE_ADMIN")`. And this is really simple. When this object is serialized if this expression fails then `isPublished` is going to be removed from the end result. So now when we do it now when you run the tests they still pass meaning that `isPublished` field is not being returned from our normal test. All right so let me open up my dragon treasure resource test again. And let me show you here so this is the original test `testGetCollectionOfTreasures` and when we're just anonymous you can see that it's not returning `isPublished` this test is passing. Now scroll down to test admin can patch to edit resource and what we can do here is when we create the `TreasureFactory` let's actually control this and make sure that it always comes with `isPublished` false. And then down here I'll `assertJsonMatches('isPublished', false)` so make sure that in this situation we do have that field. So I'll copy that test name run over and use dash dash filter to just run that test and that passes so it is being returned when we are an admin user. So one last thing I want to test here which is for the owner so I'm going to duplicate that test. I'll say test owner can see `isPublished` field and then we'll change a couple things here which I'm going to rename admin to user for clarity and then we can actually simplify this to create one and then we create the `DragonTreasureFactory::createOne()` we'll make sure that owner is set to our new user. So cool so we're and I could change this to a GET request but this is fine we're going to show it as a PATCH request and when it's serialized we're gonna make sure that it is `isPublished` field comes back. We don't expect this to pass yet we haven't done anything for this and it so let's copy that method name run just that test and yeah it does fail. So we know the drill here over here on this security thing we could inline it like we did before we could say or object dot own get owner like that but this is the whole point we created the voter we don't need to do that we can say is granted edits and then we can pass the object we still have access to that nice object variable inside of these property securities. So I try to test now got it. Notice also I haven't used it very many times but there's also a `securityPostDenormalize` and what's interesting just like with the other security post denormalize on our operations this is run after the new data is serialized onto the object. What's interesting about it here is if this expression returns false the sent data would actually be reverted. So for example if the `isPublished` field started as `false` and then the user changed it to `true` and then `securityPostDenormalize` returned `false` it would actually reverse that `isPublished` field back it up and change it back to its original value. The one thing about `securityPostDenormalize` that doesn't happen on `GET` request it only happens when data is being deserialized. So next let's finally fix our user endpoints so that they hash the password before they store in the database. This will involve a new topic called data state processors.
