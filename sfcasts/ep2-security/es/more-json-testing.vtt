WEBVTT

00:00:01.106 --> 00:00:05.476 align:middle
También podríamos querer comprobar que obtenemos los
campos correctos en la respuesta para cada elemento.

00:00:06.046 --> 00:00:08.136 align:middle
¿Podemos hacerlo con JMESPath?

00:00:08.546 --> 00:00:12.606 align:middle
¡Claro que sí! El método
assertJsonMatches() es realmente práctico.

00:00:12.976 --> 00:00:19.486 align:middle
Y en realidad, si mantienes pulsado comando o control y
haces clic en él, cuando llamamos a assertJsonMatches(),

00:00:19.666 --> 00:00:23.066 align:middle
entre bastidores, llama a $this->json().

00:00:23.716 --> 00:00:26.046 align:middle
Esto crea un objeto Json...

00:00:26.286 --> 00:00:28.476 align:middle
que tiene métodos aún más útiles.

00:00:29.076 --> 00:00:33.916 align:middle
La propia instancia Browser nos
da acceso a assertJsonMatches().

00:00:34.396 --> 00:00:38.346 align:middle
Pero si queremos utilizar cualquiera de sus otros
métodos, tenemos que hacer un poco más de trabajo.

00:00:38.916 --> 00:00:43.126 align:middle
La primera forma de utilizar el objeto Json
es a través del método use() del navegador.

00:00:43.636 --> 00:00:50.266 align:middle
Pásale una llamada de retorno con un argumento Json
$json: Esta es una función mágica del navegador:

00:00:50.486 --> 00:00:55.096 align:middle
lee la sugerencia de tipo del argumento,
y sabe que debe pasarnos el objeto Json.

00:00:55.716 --> 00:01:00.436 align:middle
También podrías pasarle un objeto CookieJar,
Crawler o algunas otras cosas. La cuestión

00:01:01.036 --> 00:01:07.196 align:middle
es que, como hemos indicado el argumento
con Json, cogerá el objeto Json

00:01:07.196 --> 00:01:09.956 align:middle
de la última respuesta y nos lo pasará.

00:01:10.496 --> 00:01:12.966 align:middle
Vamos a utilizarlo para
hacer algunos experimentos.

00:01:13.456 --> 00:01:19.296 align:middle
Queremos comprobar cuáles son las claves
del primer elemento dentro de hydra:member.

00:01:19.956 --> 00:01:24.556 align:middle
Para ayudarnos a averiguar la expresión que necesitamos,
vamos a utilizar un método llamado search().

00:01:25.006 --> 00:01:29.656 align:middle
Esto nos permite utilizar una expresión
JMESPath y obtener el resultado.

00:01:30.306 --> 00:01:34.506 align:middle
Haz las comillas dobles y luego
hydra:member para ver lo que devuelve.

00:01:34.986 --> 00:01:37.636 align:middle
Y... elimina el otro volcado: ¡Vale!

00:01:37.746 --> 00:01:41.986 align:middle
Ejecuta de nuevo la prueba: Pasa...

00:01:42.186 --> 00:01:44.666 align:middle
pero lo más importante, ¡mira el volcado!

00:01:45.126 --> 00:01:47.326 align:middle
Es el array de 5 elementos.

00:01:47.876 --> 00:01:50.356 align:middle
Vale... vamos a coger el índice 0.

00:01:50.356 --> 00:01:55.696 align:middle
Después de las comillas dobles
hydra:member, añade [0]. A

00:01:55.696 --> 00:02:00.786 align:middle
continuación, rodea todo
con una función keys()

00:02:00.786 --> 00:02:07.946 align:middle
de JMESPath: Pruébalo ahora: Qué bonito.

00:02:07.946 --> 00:02:11.286 align:middle
Y probablemente sea una de las
cosas más complejas que harás.

00:02:11.286 --> 00:02:15.436 align:middle
Ahora que tenemos la ruta correcta,
conviértela en una aserción.

00:02:16.056 --> 00:02:20.726 align:middle
Puedes hacerlo estableciendo esto en una variable
-como $keys - y utilizando una aserción normal.

00:02:21.386 --> 00:02:26.166 align:middle
O puedes cambiar search por assertMatches()
y pasar como segundo argumento

00:02:26.506 --> 00:02:33.686 align:middle
la matriz de los campos esperados: ¡Ya está!

00:02:34.176 --> 00:02:38.296 align:middle
Pruébalo: ¡Pasa!

00:02:38.566 --> 00:02:42.296 align:middle
Y sí, ahora podríamos eliminar
el método use() y pasar esto

00:02:42.296 --> 00:02:45.136 align:middle
a una llamada normal a
->assertJsonMatches().

00:02:45.906 --> 00:02:52.666 align:middle
Por muy guay que sea esto de JMESPath, es otra cosa
que hay que aprender y puede resultar complejo.

00:02:52.806 --> 00:02:54.686 align:middle
Entonces, ¿cuál es la alternativa?

00:02:54.816 --> 00:03:01.436 align:middle
Asignar toda la cadena $browser a una nueva
variable $json y luego añadir ->json() al final.

00:03:02.046 --> 00:03:03.836 align:middle
La mayoría de los métodos
de Browser devuelven...

00:03:04.056 --> 00:03:07.396 align:middle
un Browser, lo que nos permite hacer
todo el encadenamiento divertido.

00:03:08.016 --> 00:03:14.596 align:middle
Pero unos pocos, como ->json() nos permiten "salir"
del navegador para que podamos hacer algo personalizado.

00:03:15.296 --> 00:03:19.356 align:middle
Esto nos permite eliminar aquí la
función use() y sustituir las aserciones

00:03:19.356 --> 00:03:25.466 align:middle
por código PHPUnit más tradicional: Podríamos
seguir utilizando directamente el objeto Json...

00:03:25.946 --> 00:03:27.016 align:middle
que pasa...

00:03:27.566 --> 00:03:32.416 align:middle
o para quitarnos toda la fantasía,
cambiar a $this->assertSame() que

00:03:32.856 --> 00:03:41.266 align:middle
$json->decoded()['hydra:member'][0]
- array_keys() alrededor de todo -

00:03:41.266 --> 00:03:44.216 align:middle
coincide con nuestra matriz: Y por supuesto...

00:03:46.986 --> 00:03:49.126 align:middle
¡que pasa a!

00:03:49.606 --> 00:03:51.126 align:middle
Así que mucha potencia...

00:03:51.486 --> 00:03:55.546 align:middle
pero también mucha flexibilidad
para escribir pruebas como quieras.

00:03:56.326 --> 00:03:59.036 align:middle
A continuación, vamos a añadir
pruebas para la autenticación:

00:03:59.356 --> 00:04:03.536 align:middle
tanto para iniciar sesión a través de nuestro
formulario de acceso como a través de un token de API.
