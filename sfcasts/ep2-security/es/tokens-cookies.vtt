WEBVTT

00:00:01.166 --> 00:00:04.006 align:middle
Acompáñame mientras contamos
una historia tan antigua como...

00:00:04.206 --> 00:00:07.456 align:middle
la Internet moderna: La autenticación de API.

00:00:08.006 --> 00:00:12.206 align:middle
Un tema de bombo y platillo,
complejidad y héroes improbables.

00:00:12.716 --> 00:00:18.076 align:middle
Los personajes incluyen sesiones,
tokens API, OAuth, ¡tokens web JSON!

00:00:18.476 --> 00:00:21.516 align:middle
Pero, ¿qué necesitamos
para nuestra situación?

00:00:22.206 --> 00:00:26.446 align:middle
Lo primero que quiero que te preguntes
es ¿Quién va a utilizar mi API?

00:00:27.266 --> 00:00:32.646 align:middle
¿Es tu propio JavaScript, o necesitas
permitir el acceso programático?

00:00:33.236 --> 00:00:36.346 align:middle
¿Como si alguien fuera a escribir
un script que utilizara tu API?

00:00:37.186 --> 00:00:39.536 align:middle
Vamos a examinar estos dos casos de uso...

00:00:39.866 --> 00:00:43.726 align:middle
y cada uno tiene algunas complejidades
adicionales que discutiremos por el camino. Por

00:00:44.626 --> 00:00:47.546 align:middle
cierto, cuando piensas en
la autenticación de la API,

00:00:47.776 --> 00:00:50.106 align:middle
normalmente piensas en un token de API.

00:00:50.106 --> 00:00:51.536 align:middle
Y es cierto

00:00:51.986 --> 00:00:52.896 align:middle
Pero resulta que...

00:00:52.936 --> 00:00:57.386 align:middle
prácticamente toda la autenticación se
realiza mediante algún tipo de token.

00:00:58.006 --> 00:01:01.916 align:middle
Incluso la autenticación basada en
sesión se realiza enviando una cookie...

00:01:02.376 --> 00:01:06.086 align:middle
que contiene un único,
lo has adivinado, "token".

00:01:06.576 --> 00:01:12.456 align:middle
Es una cadena aleatoria que PHP utiliza para encontrar y
cargar los datos de sesión relacionados en el servidor.

00:01:13.106 --> 00:01:17.426 align:middle
Así que el truco está en averiguar qué
tipo de token necesitas en cada situación

00:01:17.776 --> 00:01:20.856 align:middle
y cómo lo obtendrá el usuario final.

00:01:21.576 --> 00:01:27.256 align:middle
Así que hablemos de ese primer caso de uso:
el usuario de tu API es tu propio JavaScript.

00:01:27.896 --> 00:01:31.936 align:middle
Bien, antes de sumergirnos en la
seguridad, asegúrate de que tu frontend

00:01:32.016 --> 00:01:35.016 align:middle
y tu API viven en el mismo dominio...

00:01:35.376 --> 00:01:38.956 align:middle
exactamente el mismo dominio,
no sólo un subdominio.

00:01:39.506 --> 00:01:43.766 align:middle
¿Por qué? Porque si viven en dos
dominios o subdominios diferentes,

00:01:44.006 --> 00:01:48.456 align:middle
tendrás que lidiar con CORS:
Intercambio de Recursos entre Orígenes.

00:01:49.186 --> 00:01:53.986 align:middle
CORS no sólo añade complejidad a tu configuración,
sino que también perjudica al rendimiento.

00:01:54.576 --> 00:02:00.056 align:middle
Kévin Dunglas -el desarrollador principal de API
Platform- tiene un artículo en su blog sobre este tema.

00:02:00.556 --> 00:02:03.856 align:middle
Incluso muestra una estrategia en la que
tu frontend y tu backend pueden vivir

00:02:03.916 --> 00:02:07.076 align:middle
en directorios o repositorios
totalmente distintos,

00:02:07.366 --> 00:02:11.946 align:middle
pero seguir viviendo en el mismo dominio
gracias a algunos trucos del servidor web.

00:02:12.816 --> 00:02:18.656 align:middle
Si, por alguna razón, decides poner tu API
y tu frontend en subdominios diferentes,

00:02:18.906 --> 00:02:25.096 align:middle
entonces tendrás que preocuparte de las cabeceras
CORS y puedes solucionarlo con NelmioCorsBundle.

00:02:25.446 --> 00:02:26.726 align:middle
Pero no te lo recomiendo.

00:02:27.546 --> 00:02:29.456 align:middle
De todos modos, volvamos a la seguridad.

00:02:30.036 --> 00:02:34.776 align:middle
Si estás llamando a tu API desde tu propio JavaScript,
es probable que el usuario se esté registrando

00:02:34.826 --> 00:02:37.486 align:middle
a través de un formulario de acceso con
un correo electrónico y una contraseña.

00:02:37.976 --> 00:02:41.846 align:middle
No importa si se trata de un formulario de
inicio de sesión tradicional o de uno creado con

00:02:41.846 --> 00:02:45.546 align:middle
un sofisticado framework JavaScript
que se envía mediante AJAX.

00:02:46.116 --> 00:02:51.686 align:middle
Y, sinceramente, una forma muy sencilla de
gestionar este caso de uso no es con tokens de API,

00:02:51.916 --> 00:02:55.756 align:middle
sino con la autenticación
básica HTTP de toda la vida.

00:02:56.346 --> 00:03:00.656 align:middle
Es decir, pasando literalmente el correo
electrónico y la contraseña a cada ruta. Por

00:03:01.336 --> 00:03:06.476 align:middle
ejemplo, el usuario introduce su correo electrónico
y contraseña, tú haces una petición API

00:03:06.476 --> 00:03:11.416 align:middle
a algún punto final sólo para asegurarte de que es válido,
luego almacenas ese correo electrónico y contraseña

00:03:11.416 --> 00:03:16.486 align:middle
en JavaScript y lo envías en cada
petición API que se realice en adelante.

00:03:17.146 --> 00:03:21.286 align:middle
Tu correo electrónico y contraseña
funcionan básicamente como un token API.

00:03:22.006 --> 00:03:25.226 align:middle
Sin embargo, esto tiene
algunos retos prácticos,

00:03:25.446 --> 00:03:29.766 align:middle
como la cuestión de dónde almacenas de forma segura
el correo electrónico y la contraseña en JavaScript

00:03:29.766 --> 00:03:33.236 align:middle
para poder utilizarlos continuamente. En

00:03:33.916 --> 00:03:38.706 align:middle
realidad, éste es un problema en general
con JavaScript y las "credenciales",

00:03:39.066 --> 00:03:44.006 align:middle
incluidos los tokens de API: tienes que tener
mucho cuidado con dónde los almacenas para que

00:03:44.366 --> 00:03:47.686 align:middle
otro JavaScript de tu página no pueda leerlos.

00:03:48.236 --> 00:03:54.176 align:middle
Hay soluciones:
https://bit.ly/auth0-token-storage -

00:03:54.336 --> 00:03:57.616 align:middle
pero añade una complejidad que
muy probablemente no necesites.

00:03:57.616 --> 00:04:00.486 align:middle
Así que en su lugar, para tu propio
JavaScript, puedes utilizar una sesión.

00:04:00.486 --> 00:04:04.776 align:middle
Cuando inicias una sesión en Symfony,
devuelve una cookie "sólo HTTP"...

00:04:04.776 --> 00:04:07.356 align:middle
y esa cookie contiene el id de sesión.

00:04:07.876 --> 00:04:12.596 align:middle
Aunque, el contenido de la cookie no es
realmente importante: puede ser el id de sesión

00:04:12.706 --> 00:04:16.186 align:middle
o algún tipo de token que hayas
inventado y estés leyendo en Symfony.

00:04:16.746 --> 00:04:21.746 align:middle
Lo realmente importante es que,
como la cookie es "sólo HTTP",

00:04:22.206 --> 00:04:27.846 align:middle
no puede ser leída por JavaScript: ni
por tu JavaScript ni por el de nadie.

00:04:27.846 --> 00:04:33.636 align:middle
Pero siempre que hagas una petición a la API
de tu dominio, esa cookie vendrá con ella...

00:04:33.936 --> 00:04:36.586 align:middle
y tu aplicación la utilizará para
iniciar la sesión del usuario.

00:04:37.236 --> 00:04:41.356 align:middle
Así que el token de la API en esta situación
es simplemente el "identificador de sesión",

00:04:41.576 --> 00:04:45.266 align:middle
que se almacena de forma segura
en una cookie sólo HTTP.

00:04:45.746 --> 00:04:49.226 align:middle
Mmmm. Vamos a codificar este caso de uso.

00:04:49.816 --> 00:04:53.616 align:middle
Ah, y por cierto, un caso
extremo en esta situación es

00:04:53.616 --> 00:04:57.596 align:middle
si tienes una situación de
Inicio de Sesión Único - un SSO.

00:04:58.246 --> 00:05:02.656 align:middle
En ese caso, te autenticarás con tu
SSO como una aplicación web normal.

00:05:03.136 --> 00:05:06.626 align:middle
Cuando termines, tendrás un
token, que podrás utilizar

00:05:06.626 --> 00:05:09.456 align:middle
para autenticar al usuario
con una sesión normal...

00:05:09.816 --> 00:05:12.856 align:middle
o puedes utilizar ese token
directamente desde tu JavaScript.

00:05:13.376 --> 00:05:17.256 align:middle
Ese es un caso de uso más avanzado
que no trataremos en este tutorial...

00:05:17.746 --> 00:05:19.596 align:middle
aunque sí hablaremos de cómo

00:05:19.596 --> 00:05:24.146 align:middle
leer y validar los tokens de la API,
independientemente de su procedencia.

00:05:25.076 --> 00:05:29.386 align:middle
El segundo gran caso de uso de la
autenticación es el acceso programático.

00:05:29.856 --> 00:05:32.026 align:middle
Algún código hablará con tu API...

00:05:32.586 --> 00:05:34.856 align:middle
además de JavaScript
desde dentro del navegador.

00:05:35.646 --> 00:05:41.856 align:middle
En este caso, los clientes de la API enviarán
absolutamente algún tipo de cadena de token de la API. Por

00:05:42.426 --> 00:05:47.676 align:middle
tanto, tienes que hacer que tu API pueda
leer un token que se envía en cada

00:05:48.106 --> 00:05:54.076 align:middle
petición, normalmente en una cabecera Authorization:
Cómo obtiene el usuario este token depende:

00:05:54.516 --> 00:05:56.476 align:middle
hay dos casos principales.

00:05:56.946 --> 00:06:00.686 align:middle
El primero es el caso del "token de
acceso personal a GitHub". En este

00:06:01.186 --> 00:06:03.806 align:middle
caso, un usuario puede ir
a una página de tu sitio

00:06:04.106 --> 00:06:06.386 align:middle
y hacer clic para crear
un nuevo token de acceso.

00:06:06.876 --> 00:06:09.916 align:middle
Luego puede copiarlo y
utilizarlo en algún código.

00:06:10.736 --> 00:06:17.486 align:middle
El segundo gran caso es OAuth, que no es más que una
forma elegante y segura de obtener un token de acceso. Es

00:06:18.016 --> 00:06:24.296 align:middle
especialmente importante cuando el "código"
que realiza las peticiones a la API lo hace en

00:06:24.536 --> 00:06:27.696 align:middle
"nombre" de algún usuario de tu sistema.

00:06:28.316 --> 00:06:32.406 align:middle
Por ejemplo, imagina un sitio -R
ReplyToAllCommentsWithHearts.com-

00:06:32.846 --> 00:06:35.056 align:middle
que te permite conectarte con GitHub.

00:06:35.636 --> 00:06:41.816 align:middle
Una vez lo hayas hecho, ese sitio puede hacer
peticiones de API a GitHub para tu cuenta,

00:06:42.106 --> 00:06:44.816 align:middle
como hacer comentarios como tu usuario.

00:06:45.446 --> 00:06:51.896 align:middle
O imagina una aplicación para iPhone en la que, para iniciar sesión,
muestres al usuario el formulario de inicio de sesión de tu sitio.

00:06:52.376 --> 00:06:58.746 align:middle
Entonces, a través de un flujo OAuth, esa aplicación móvil
recibirá un token de acceso que podrá utilizar para hablar

00:06:58.746 --> 00:07:01.626 align:middle
con tu API en nombre de ese usuario.

00:07:02.446 --> 00:07:06.486 align:middle
En este tutorial vamos a hablar del
método del token de acceso personal,

00:07:06.936 --> 00:07:12.316 align:middle
incluyendo cómo leer y validar los
tokens de la API, vengan de donde vengan.

00:07:13.036 --> 00:07:14.906 align:middle
No hablaremos del flujo OAuth...

00:07:15.346 --> 00:07:18.616 align:middle
y en parte es porque es una bestia aparte.

00:07:19.216 --> 00:07:25.156 align:middle
Sí, si tienes un caso de uso en el que necesitas
permitir que terceros obtengan tokens de API

00:07:25.156 --> 00:07:30.386 align:middle
para diferentes usuarios de tu sitio,
necesitarás algún tipo de servidor OAuth,

00:07:30.936 --> 00:07:34.486 align:middle
tanto si lo construyes tú mismo como
si utilizas alguna otra solución.

00:07:35.106 --> 00:07:40.916 align:middle
Pero una vez que el servidor OAuth ha hecho su
trabajo, el cliente que hablará con tu API recibe...

00:07:41.246 --> 00:07:45.916 align:middle
¡un token! Y luego utilizarán
ese token para hablar con tu API.

00:07:46.736 --> 00:07:51.046 align:middle
Así que tu API necesitará leer,
validar y entender ese token,

00:07:51.456 --> 00:07:55.416 align:middle
pero no le importa cómo lo
obtuvo el cliente de la API.

00:07:56.276 --> 00:08:01.976 align:middle
Bien, dejemos atrás toda esta teoría y comencemos
a continuación con el primer caso de uso:

00:08:02.416 --> 00:08:06.356 align:middle
permitir que nuestro JavaScript inicie
sesión enviando una petición AJAX.
