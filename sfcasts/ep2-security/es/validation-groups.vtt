WEBVTT

00:00:01.066 --> 00:00:04.796 align:middle
Ahora que la propiedad
plainPassword es una parte legítima

00:00:04.796 --> 00:00:06.966 align:middle
de nuestra API, añadamos
algo de validación...

00:00:07.246 --> 00:00:09.736 align:middle
¡porque no puedes crear un
nuevo usuario sin contraseña!

00:00:10.416 --> 00:00:13.756 align:middle
Añade Assert\NotBlank: ¡Fácil!

00:00:14.286 --> 00:00:17.026 align:middle
Bueno, eso acaba de crear un nuevo problema...

00:00:17.296 --> 00:00:20.296 align:middle
pero avancemos a ciegas y
hagamos como si todo fuera bien.

00:00:21.396 --> 00:00:26.956 align:middle
Copia la primera prueba y pégala para crear un segundo
método que nos asegure que podemos actualizar los usuarios.

00:00:27.916 --> 00:00:29.996 align:middle
Llámalo testPatchToUpdateUser().

00:00:31.286 --> 00:00:37.166 align:middle
Este es sencillo: crea un nuevo usuario
- $user = UserFactory::createOne(),

00:00:38.606 --> 00:00:42.646 align:middle
añade actingAs($user) luego ->patch()

00:00:43.116 --> 00:00:49.036 align:middle
a /api/users/ luego $user->getId()
para editarnos a nosotros mismos.

00:00:49.756 --> 00:00:55.496 align:middle
Para el json, basta con enviar
username, añadir assertStatus(200)....

00:00:56.416 --> 00:01:03.546 align:middle
entonces no necesitamos ninguna de estas otras cosas: Como
recordatorio, arriba en la operación Patch para User...

00:01:05.186 --> 00:01:09.606 align:middle
aquí está, estamos requiriendo
que el usuario tenga ROLE_USER_EDIT.

00:01:10.416 --> 00:01:14.036 align:middle
Como estamos entrando como usuario
"completo", deberíamos tener eso...

00:01:14.446 --> 00:01:16.266 align:middle
y todo debería funcionar bien...

00:01:16.696 --> 00:01:18.196 align:middle
famosas últimas palabras.

00:01:18.756 --> 00:01:26.696 align:middle
Ejecuta: symfony php bin/phpunit
--filter=testPatchToUpdateUser Y...

00:01:27.246 --> 00:01:31.366 align:middle
¡oh! 200 esperados, obtuve 415.

00:01:31.686 --> 00:01:32.666 align:middle
¡Eso es nuevo!

00:01:33.356 --> 00:01:34.796 align:middle
Haz clic para abrir la última respuesta...

00:01:35.326 --> 00:01:37.586 align:middle
luego veré la fuente
para que quede más claro.

00:01:38.956 --> 00:01:43.866 align:middle
Interesante: El tipo de contenido:
application/json no es compatible.

00:01:44.316 --> 00:01:49.106 align:middle
Los tipos MIME admitidos son
application/merge-patch+json.

00:01:49.696 --> 00:01:51.336 align:middle
Desmenucemos esto.

00:01:52.056 --> 00:01:54.006 align:middle
Estamos haciendo una petici ón a PATCH...

00:01:54.376 --> 00:01:59.236 align:middle
y las peticiones a PATCH son bastante
sencillas: enviamos un subconjunto de campos,

00:01:59.366 --> 00:02:01.866 align:middle
y sólo se actualizan esos campos. Resulta

00:02:02.686 --> 00:02:07.866 align:middle
que el método HTTP PATCH puede ser mucho

00:02:07.866 --> 00:02:09.906 align:middle
más interesante que esto. En

00:02:10.586 --> 00:02:16.536 align:middle
la gran interwebs, hay formatos que compiten
por el aspecto que deben tener los datos

00:02:16.646 --> 00:02:21.406 align:middle
cuando se utiliza una petición PATCH,
y cada formato significa algo diferente.

00:02:22.276 --> 00:02:28.996 align:middle
Actualmente, API Platform sólo admite uno de
estos formatos: application/merge-patch+json.

00:02:29.926 --> 00:02:30.966 align:middle
Este formato es...

00:02:31.216 --> 00:02:32.826 align:middle
más o menos lo que esperas.

00:02:33.226 --> 00:02:37.936 align:middle
Dice: si envías un único campo,
sólo se modificará ese único campo.

00:02:38.386 --> 00:02:43.136 align:middle
Pero también tiene otras reglas, como
que podrías cambiar email por null...

00:02:43.616 --> 00:02:46.906 align:middle
y eso en realidad eliminaría el campo email.

00:02:47.616 --> 00:02:53.056 align:middle
Eso no tiene mucho sentido en nuestra API,
pero la cuestión es: el formato define reglas

00:02:53.056 --> 00:02:57.816 align:middle
sobre el aspecto que debe tener tu JSON para una
petición a PATCH y lo que eso significa. Si quieres

00:02:58.476 --> 00:03:00.706 align:middle
saber más, hay un documento

00:03:00.706 --> 00:03:03.736 align:middle
que lo describe todo: es
bastante breve y legible.

00:03:04.486 --> 00:03:10.106 align:middle
Así que, por el momento, API Platform sólo
admite un formato para las peticiones PATCH.

00:03:10.556 --> 00:03:13.016 align:middle
Pero, en el futuro, podrían admitir más.

00:03:13.716 --> 00:03:18.906 align:middle
Y así, cuando haces una petición
a PATCH, API Platform requiere

00:03:18.906 --> 00:03:24.366 align:middle
que envíes una cabecera Content-Type
establecida en application/merge-patch+json...

00:03:24.746 --> 00:03:30.996 align:middle
para que le digas explícitamente a la API
Platform qué formato está utilizando tu JSON. En

00:03:31.786 --> 00:03:38.796 align:middle
otras palabras, para solucionar nuestro error, pasa
una clave headers con Content-Type establecido en

00:03:38.916 --> 00:03:49.806 align:middle
application/merge-patch+json: Inténtalo ahora: Sigue
fallando, ¡pero ahora es un error de validación!

00:03:50.656 --> 00:03:55.976 align:middle
Las conclusiones son sencillas: Las peticiones
PATCH requieren esta cabecera Content-Type.

00:03:56.796 --> 00:04:01.936 align:middle
Pero, ¡espera! Hicimos un montón de
peticiones a PATCH en DragonTreasureResourceTest

00:04:02.396 --> 00:04:04.836 align:middle
y ¡funcionaron bien sin la cabecera!

00:04:05.326 --> 00:04:05.976 align:middle
¿Qué?

00:04:06.756 --> 00:04:09.616 align:middle
Eso... fue un poco por accidente.

00:04:10.456 --> 00:04:13.196 align:middle
Dentro de DragonTreasure,
en el primer tutorial...

00:04:13.916 --> 00:04:20.406 align:middle
aquí está, añadimos una clave formats
para poder añadir soporte CSV: Resulta que,

00:04:20.756 --> 00:04:24.416 align:middle
por algunas complejas razones
internas, al añadir formats,

00:04:24.816 --> 00:04:27.836 align:middle
eliminamos el requisito
de necesitar esa cabecera.

00:04:28.466 --> 00:04:33.576 align:middle
Así que nos "salimos con la nuestra" al no establecer
la cabecera en DragonTreasureResourceTest...

00:04:34.026 --> 00:04:35.806 align:middle
aunque deberíamos ponerla.

00:04:36.296 --> 00:04:40.996 align:middle
Quizá hubiera sido mejor fijar formats
sólo en la operación GetCollection...

00:04:41.306 --> 00:04:43.406 align:middle
ya que ése es el único punto
en el que necesitamos CSV.

00:04:44.196 --> 00:04:48.536 align:middle
En fin, por eso antes no lo
necesitábamos, pero ahora sí. Por

00:04:49.456 --> 00:04:53.896 align:middle
cierto, si añadir esta cabecera cada vez
que llamas a ->patch te resulta molesto,

00:04:54.316 --> 00:05:01.116 align:middle
ésta es otra situación en la que podrías añadir un
método personalizado al navegador -como ->apiPatch() -

00:05:01.616 --> 00:05:05.186 align:middle
que funcionaría igual, pero añadiría
esa cabecera automáticamente.

00:05:06.746 --> 00:05:08.466 align:middle
Vale, ¡volvamos a la prueba!

00:05:08.816 --> 00:05:10.586 align:middle
Está fallando con un 422.

00:05:11.276 --> 00:05:12.736 align:middle
Abre la respuesta de error.

00:05:13.736 --> 00:05:18.166 align:middle
Ah, es de plainPassword: ¡este
campo no debería estar en blanco!

00:05:18.696 --> 00:05:22.036 align:middle
La propiedad plainPassword no
se persiste en la base de datos.

00:05:22.326 --> 00:05:26.566 align:middle
Por tanto, siempre está vacía al
inicio de una petición a la API.

00:05:27.156 --> 00:05:31.936 align:middle
Cuando creamos un User, queremos
absolutamente que este campo sea obligatorio.

00:05:32.486 --> 00:05:36.546 align:middle
Pero cuando editamos un User, no necesitamos
que este campo esté establecido.

00:05:37.216 --> 00:05:41.596 align:middle
Pueden establecerlo para cambiar su
contraseña, pero eso es opcional.

00:05:42.386 --> 00:05:47.686 align:middle
Este es el primer punto en el que necesitamos
validación condicional: la validación debe producirse

00:05:47.686 --> 00:05:50.736 align:middle
en una operación, pero no en otras.

00:05:51.456 --> 00:05:57.346 align:middle
La forma de solucionarlo es con grupos de validación,
que es muy similar a los grupos de serialización. ¡

00:05:58.086 --> 00:06:03.736 align:middle
Busca la operación Post y pásale una
nueva opción llamada validationContext con,

00:06:04.236 --> 00:06:05.966 align:middle
lo has adivinado, groups !

00:06:07.056 --> 00:06:14.636 align:middle
Ponlo en un array con un grupo llamado Default
con D mayúscula. Luego inventa un segundo grupo:

00:06:14.876 --> 00:06:20.476 align:middle
postValidation: Cuando el validador
valida un objeto, por defecto,

00:06:20.796 --> 00:06:24.236 align:middle
valida todo lo que está en
un grupo llamado Default.

00:06:24.686 --> 00:06:31.366 align:middle
Y cada vez que tengas una restricción, por defecto
esa restricción estará en ese grupo Default.

00:06:32.226 --> 00:06:33.936 align:middle
Así que lo que estamos diciendo aquí es

00:06:34.326 --> 00:06:39.076 align:middle
Queremos validar todas las restricciones
normales más cualquier restric ción

00:06:39.076 --> 00:06:41.146 align:middle
que esté en el grupo postValidation.

00:06:42.086 --> 00:06:48.466 align:middle
Ahora podemos coger ese postValidation, bajar a
plainPassword y poner groups en postValidation:

00:06:49.196 --> 00:06:52.546 align:middle
Eso elimina esta restricción del grupo Default

00:06:52.986 --> 00:06:56.196 align:middle
y sólo la incluye en el grupo postValidation.

00:06:56.936 --> 00:07:04.156 align:middle
Gracias a esto, otras operaciones como Patch
no la ejecutarán, pero sí la operación Post.

00:07:05.076 --> 00:07:09.596 align:middle
Ejecuta ahora la prueba: ¡Somos imparables!

00:07:10.526 --> 00:07:12.736 align:middle
De hecho, ¡todas nuestras
pruebas están pasando!

00:07:13.696 --> 00:07:14.376 align:middle
Pero ¡cuidado!

00:07:14.786 --> 00:07:17.846 align:middle
En User, todavía tenemos tanto Put como Patch.

00:07:18.386 --> 00:07:21.536 align:middle
Aún no he jugado mucho con ello,
pero el nuevo comportamiento Put,

00:07:21.796 --> 00:07:25.366 align:middle
en teoría, sí admite la creación de objetos.

00:07:26.086 --> 00:07:30.606 align:middle
Esto puede complicar las cosas:
¿necesitamos exigir la contraseña o no?

00:07:31.236 --> 00:07:32.246 align:middle
Depende

00:07:32.886 --> 00:07:37.426 align:middle
Ésta podría ser otra razón para eliminar
la operación Put y simplificar las cosas.

00:07:37.956 --> 00:07:43.186 align:middle
Así tenemos una operación
para crear y otra para editar.

00:07:44.266 --> 00:07:49.366 align:middle
Siguiente: vamos a explorar la posibilidad de hacer que nuestros
grupos de serialización sean dinámicos en función del usuario.

00:07:50.086 --> 00:07:55.746 align:middle
Esto nos dará otra forma de incluir o no incluir
campos en función de quién esté conectado.

00:07:56.136 --> 00:07:59.746 align:middle
Y nos llevará a añadir
campos superpersonalizados.
