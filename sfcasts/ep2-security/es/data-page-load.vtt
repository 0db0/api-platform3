WEBVTT

00:00:01.056 --> 00:00:02.996 align:middle
¿Qué significa "desconectarse" de algo?

00:00:03.186 --> 00:00:05.036 align:middle
¿Como desconectarse de una API?

00:00:05.916 --> 00:00:07.026 align:middle
Bueno, son dos cosas.

00:00:07.396 --> 00:00:11.016 align:middle
En primer lugar, significa invalidar
el token que tengas, si es posible.

00:00:11.656 --> 00:00:15.456 align:middle
Por ejemplo, si tienes un token
de API, le dirías a la API:

00:00:16.116 --> 00:00:18.926 align:middle
Haz que este token de API deje de ser válido.

00:00:19.536 --> 00:00:22.756 align:middle
En el caso de la autenticación de
sesión, es básicamente lo mismo:

00:00:23.006 --> 00:00:25.636 align:middle
significa eliminar la sesión
del almacén de sesiones.

00:00:26.246 --> 00:00:31.516 align:middle
La segunda parte de "cerrar la sesión" es hacer
que quien esté utilizando el token lo "olvide".

00:00:32.326 --> 00:00:37.186 align:middle
Si tuvieras un token de API en
JavaScript, lo eliminarías de JavaScript.

00:00:37.746 --> 00:00:40.826 align:middle
Para la autenticación de sesión,
significa eliminar la cookie.

00:00:41.716 --> 00:00:46.586 align:middle
En cualquier caso, vamos a añadir la posibilidad de cerrar
la sesión de nuestra autenticación basada en sesión.

00:00:47.276 --> 00:00:51.856 align:middle
Volviendo a SecurityController, como antes,
necesitamos una ruta y un controlador,

00:00:52.256 --> 00:00:54.686 align:middle
aunque este controlador nunca será llamado.

00:00:55.186 --> 00:00:58.786 align:middle
Llamaré al método logout()
y devolveremos void.

00:00:59.256 --> 00:01:00.786 align:middle
Verás por qué en un segundo. Dale a

00:01:01.666 --> 00:01:09.576 align:middle
esto un Route de /logout y name: app_logout: La
razón por la que he elegido void es porque vamos a

00:01:09.576 --> 00:01:13.256 align:middle
lanzar una excepción desde dentro del método.

00:01:13.706 --> 00:01:17.656 align:middle
Hemos creado esto completamente
porque necesitamos una ruta:

00:01:18.186 --> 00:01:22.596 align:middle
El sistema de seguridad de Symfony interceptará
las cosas antes de que se llame al controlador:

00:01:23.526 --> 00:01:31.006 align:middle
Para activar esa magia, en security.yaml, añade
una clave llamada logout con path debajo configurada

00:01:31.006 --> 00:01:33.966 align:middle
con ese nuevo nombre de ruta: app_logout:

00:01:34.796 --> 00:01:40.596 align:middle
Esto activa un oyente que ahora está
atento a las peticiones a /logout.

00:01:41.506 --> 00:01:46.626 align:middle
Cuando haya una petición a /logout, cerrará
la sesión del usuario y lo redirigirá.

00:01:47.346 --> 00:01:52.756 align:middle
Muy bien, por aquí, nuestra aplicación Vue cree
que no estamos conectados, pero sí lo estamos:

00:01:53.216 --> 00:01:55.156 align:middle
podemos verlo en la barra de
herramientas de depuración web.

00:01:55.716 --> 00:01:58.596 align:middle
Y si vamos manualmente a /logout...

00:01:59.346 --> 00:02:02.726 align:middle
¡boom! Ahora estamos realmente desconectados.

00:02:03.416 --> 00:02:08.016 align:middle
Así que hemos visto hace un momento que, aunque
hayamos iniciado sesión y la actualicemos,

00:02:08.246 --> 00:02:11.426 align:middle
nuestra aplicación Vue no tiene ni
idea de que hemos iniciado sesión.

00:02:12.046 --> 00:02:13.166 align:middle
¿Cómo podríamos solucionarlo?

00:02:13.846 --> 00:02:18.826 align:middle
Una idea sería crear una ruta API /me.

00:02:19.536 --> 00:02:24.606 align:middle
Entonces, al cargarse, nuestra aplicación Vue
podría hacer una petición AJAX a esa ruta...

00:02:24.776 --> 00:02:29.016 align:middle
que devolvería null o la
información actual del usuario.

00:02:29.546 --> 00:02:33.486 align:middle
Pero las rutas /me no son RESTful.

00:02:33.856 --> 00:02:39.186 align:middle
Y hay una forma mejor: volcar la información
del usuario en JavaScript al cargar la página.

00:02:39.806 --> 00:02:41.516 align:middle
Hay dos formas distintas de hacerlo.

00:02:41.976 --> 00:02:44.126 align:middle
La primera es estableciendo
una variable global. Por

00:02:44.826 --> 00:02:50.316 align:middle
ejemplo, en templates/base.html.twig
, en realidad no importa dónde,

00:02:50.846 --> 00:02:53.336 align:middle
pero dentro del cuerpo,
añade una etiqueta script.

00:02:54.446 --> 00:03:01.966 align:middle
Y aquí digamos window.user = y
luego {{ app.user|serialize }}.

00:03:02.746 --> 00:03:09.366 align:middle
Serializa en jsonld y añade una
|raw para que no se escape la salida:

00:03:09.866 --> 00:03:13.586 align:middle
queremos JSON sin procesar: ¿a que mola?

00:03:14.056 --> 00:03:16.586 align:middle
En un minuto, lo leeremos
desde nuestro JavaScript.

00:03:17.466 --> 00:03:21.486 align:middle
Si refrescamos ahora mismo y
miramos el código fuente, ¡sí!

00:03:22.036 --> 00:03:24.286 align:middle
Vemos window.user = null.

00:03:24.286 --> 00:03:31.656 align:middle
Y luego, cuando iniciemos sesión y
actualicemos la página, ¡compruébalo!

00:03:32.006 --> 00:03:35.926 align:middle
window.user = ¡y una enorme cantidad de datos!

00:03:36.746 --> 00:03:41.726 align:middle
Pero ocurre algo misterioso: ¡tiene
los campos correctos! Fíjate

00:03:42.146 --> 00:03:45.256 align:middle
bien, tiene email, username

00:03:45.576 --> 00:03:49.256 align:middle
y luego dragonTreasures , que
es lo que son todas estas cosas.

00:03:50.046 --> 00:03:55.456 align:middle
Además, correctamente, no
tiene roles ni password.

00:03:56.346 --> 00:04:01.236 align:middle
¡Así que parece que está leyendo
correctamente nuestros grupos de normalización!

00:04:01.666 --> 00:04:03.326 align:middle
Pero, ¿cómo es eso posible?

00:04:03.986 --> 00:04:07.596 align:middle
Sólo estamos diciendo "serializa
este usuario a jsonld ".

00:04:08.176 --> 00:04:14.376 align:middle
Esto no tiene nada que ver con la API
Platform y no está siendo procesado por ella.

00:04:14.966 --> 00:04:19.886 align:middle
Pero... nuestros grupos de normalización
están configurados en API Platform.

00:04:20.346 --> 00:04:23.816 align:middle
Entonces, ¿cómo sabe el
serializador que debe utilizarlos?

00:04:24.576 --> 00:04:28.946 align:middle
La respuesta a eso, lo mejor que
puedo decir, es que funciona...

00:04:29.206 --> 00:04:30.566 align:middle
parcialmente por accidente.

00:04:31.136 --> 00:04:37.426 align:middle
Durante la serialización, API Platform ve
que estamos serializando un "recurso API"

00:04:37.646 --> 00:04:40.946 align:middle
y busca los metadatos de esta clase.

00:04:41.616 --> 00:04:42.876 align:middle
Eso está bien...

00:04:43.096 --> 00:04:45.516 align:middle
pero en realidad no es perfecto...

00:04:45.816 --> 00:04:47.726 align:middle
y de todas formas me gusta ser explícito.

00:04:48.656 --> 00:04:56.356 align:middle
Pasa un 2º argumento a serializar, que es
el contexto y pon groups a user:read: Ahora,

00:04:56.446 --> 00:04:58.646 align:middle
observa lo que ocurre cuando actualizamos.

00:04:59.156 --> 00:05:03.256 align:middle
Como antes, se expondrán las
propiedades correctas en User.

00:05:03.746 --> 00:05:07.356 align:middle
Pero no pierdas de vista la
propiedad dragonTreasures incrustada.

00:05:08.306 --> 00:05:10.056 align:middle
Vaya, ¡ha cambiado!

00:05:10.516 --> 00:05:14.936 align:middle
Antes estaba mal: incluía todo,

00:05:15.086 --> 00:05:18.186 align:middle
no sólo lo que estaba
dentro del grupo user:read.

00:05:19.116 --> 00:05:25.356 align:middle
Bien, vamos a utilizar esta variable global
en JavaScript: en TreasureConnectApp.vue.

00:05:26.206 --> 00:05:29.356 align:middle
Ahora mismo, los datos de user
siempre empiezan como null.

00:05:29.836 --> 00:05:34.396 align:middle
Podemos cambiarlo a window.user:
Cuando actualicemos...

00:05:35.016 --> 00:05:40.956 align:middle
¡ya está! Siguiente: si utilizas Stimulus,
una forma aún mejor de pasar datos

00:05:40.956 --> 00:05:44.136 align:middle
a JavaScript es utilizar valores Stimulus.
