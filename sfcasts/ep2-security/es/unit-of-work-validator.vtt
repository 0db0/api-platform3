WEBVTT

00:00:01.046 --> 00:00:05.566 align:middle
¡Seguimos teniendo un gran problema para asegurarnos
de que los tesoros no acaban siendo robados!

00:00:06.176 --> 00:00:10.976 align:middle
Acabamos de cubrir el caso principal: si haces
una petición POST o PUT a una ruta de tesoro,

00:00:11.326 --> 00:00:15.066 align:middle
gracias a nuestra nueva validación, nos
aseguramos de que te asignes el propietario

00:00:15.066 --> 00:00:18.466 align:middle
a ti mismo, a menos que seas un administrador.

00:00:18.466 --> 00:00:24.696 align:middle
¡Sí! Pero en nuestra API, al hacer una
solicitud POST o PUT a una ruta de usuario, se

00:00:25.046 --> 00:00:28.136 align:middle
te permite enviar un campo dragonTreasures.

00:00:28.726 --> 00:00:32.926 align:middle
Esto, por desgracia, permite robar tesoros.

00:00:33.536 --> 00:00:37.726 align:middle
Simplemente envía una petición PATCH
para modificar tu propio registro User...

00:00:38.146 --> 00:00:42.896 align:middle
y luego establecer el campo dragonTreasures
en una matriz que contenga las cadenas IRI

00:00:42.966 --> 00:00:45.726 align:middle
de algunos tesoros que no te pertenezcan.

00:00:46.226 --> 00:00:49.496 align:middle
¡Uy! La solución más sencilla sería...

00:00:49.886 --> 00:00:51.626 align:middle
hacer que el campo no sea escribible.

00:00:52.086 --> 00:00:54.766 align:middle
Así, dentro de User, para dragonTreasures,

00:00:55.096 --> 00:00:58.546 align:middle
lo mantendríamos legible, pero
eliminaríamos el grupo de escritura.

00:00:59.126 --> 00:01:00.146 align:middle
Eso obligaría a todo el mundo

00:01:00.146 --> 00:01:04.926 align:middle
a utilizar las rutas de /api/treasures
para gestionar sus tesoros.

00:01:05.596 --> 00:01:08.696 align:middle
Si quieres mantener el campo
dragonTreasures escribible...

00:01:08.916 --> 00:01:12.316 align:middle
puedes hacerlo, pero este
problema es difícil de resolver.

00:01:13.006 --> 00:01:17.856 align:middle
Pensemos: si envías un campo
dragonTreasures que contiene el IRI

00:01:17.856 --> 00:01:22.696 align:middle
de un tesoro que no posees, eso debería
provocar un error de validación.

00:01:23.396 --> 00:01:28.096 align:middle
Vale... ¿podríamos añadir una restricción
de validación sobre esta propiedad?

00:01:28.786 --> 00:01:33.826 align:middle
El problema es que, para cuando se ejecuta
esa validación, los tesor os enviados

00:01:33.826 --> 00:01:39.136 align:middle
en el JSON ya se han establecido
en esta propiedad dragonTreasures.

00:01:39.766 --> 00:01:46.236 align:middle
Y lo que es más importante, ¡el owner de
esos tesoros ya se ha actualizado a este User !

00:01:46.966 --> 00:01:52.456 align:middle
Recuerda: cuando el serializador vea un
DragonTreasure que no pertenezca ya a

00:01:52.456 --> 00:01:55.606 align:middle
este usuario, llamará a addDragonTreasure()...

00:01:55.986 --> 00:01:59.386 align:middle
que a su vez llamará a setOwner($this).

00:02:00.046 --> 00:02:05.586 align:middle
Así que, cuando se ejecute la validación,
parecerá que somos los propietarios del tesoro...

00:02:05.876 --> 00:02:08.106 align:middle
¡aunque originalmente no lo fuéramos!

00:02:08.726 --> 00:02:09.756 align:middle
¿Qué podemos hacer?

00:02:10.436 --> 00:02:14.636 align:middle
Bueno, API Platform tiene un concepto de
"datos anteriores". La API Platform clona

00:02:15.316 --> 00:02:21.126 align:middle
los datos antes de deserializar
el nuevo JSON sobre ellos,

00:02:21.586 --> 00:02:26.836 align:middle
lo que significa que es posible obtener
el aspecto original del objeto User.

00:02:27.386 --> 00:02:34.326 align:middle
Desgraciadamente, ese clon es superficial, lo que
significa que clona campos escalares -como username -,

00:02:34.666 --> 00:02:39.806 align:middle
pero no clona ningún objeto
-como los objetos DragonTreasure.

00:02:40.296 --> 00:02:45.496 align:middle
No hay forma, a través de la API Platform,
de ver qué aspecto tenían originalmente.

00:02:46.236 --> 00:02:48.856 align:middle
Así que vamos a resolver
esto con la validación...

00:02:49.196 --> 00:02:53.996 align:middle
pero con la ayuda de una clase especial
de Doctrine llamada UnitOfWork.

00:02:54.836 --> 00:02:58.556 align:middle
Muy bien, vamos a hacer una prueba
para aclarar este molesto error.

00:02:59.086 --> 00:03:02.236 align:middle
Dentro de tests/Functional/,
abre UserResourceTest.

00:03:03.426 --> 00:03:10.946 align:middle
Copia la prueba anterior, pégala y
llámala testTreasuresCannotBeStolen().

00:03:13.376 --> 00:03:17.146 align:middle
Crea un segundo usuario con
UserFactory::createOne()...

00:03:17.816 --> 00:03:21.496 align:middle
y necesitamos un DragonTreasure
que vamos a intentar robar.

00:03:22.896 --> 00:03:27.406 align:middle
Asigna su owner a $otherUser:
¡Vamos a hacerlo! Nos registramos

00:03:27.916 --> 00:03:34.186 align:middle
como $user, nos actualizamos -lo cual
está permitido- y luego, para el JSON,

00:03:34.566 --> 00:03:36.976 align:middle
claro, quizá sigamos enviando username...

00:03:37.266 --> 00:03:40.956 align:middle
pero también enviamos dragonTreasures
configurado en una matriz

00:03:41.356 --> 00:03:46.326 align:middle
con /api/treasures/ y
$dragonTreasure->getId().

00:03:46.396 --> 00:03:53.446 align:middle
Al final, afirma que esto
devuelve un 422: ¡Vale!

00:03:53.786 --> 00:03:54.896 align:middle
Copia el nombre del método.

00:03:55.776 --> 00:03:59.726 align:middle
Esperamos que esto falle: Y...

00:04:00.396 --> 00:04:06.366 align:middle
¡falla! Código de estado 200, ¡lo que significa
que estamos permitiendo que nos roben el tesoro!

00:04:06.776 --> 00:04:10.646 align:middle
¡Qué susto! Vale, vamos a crear una
nueva clase validadora: php ./bin/console

00:04:11.096 --> 00:04:16.596 align:middle
make:validator Llámala
TreasuresAllowedOwnerChange. Ve a

00:04:17.836 --> 00:04:19.226 align:middle
utilizarla inmediatamente. Encima

00:04:19.826 --> 00:04:26.086 align:middle
de la propiedad dragonTreasures, añade
#[TreasuresAllowedOwnerChange]: A continuación,

00:04:26.176 --> 00:04:29.726 align:middle
en src/Validator/, abre la clase validadora.

00:04:30.386 --> 00:04:34.056 align:middle
Haremos una limpieza básica: utiliza
la función assert() para afirmar que

00:04:34.056 --> 00:04:37.636 align:middle
$constraint es una instancia de
TreasuresAllowedOwnerChange. Y

00:04:39.086 --> 00:04:43.726 align:middle
también afirma que value es una
instancia de Collection de Doctrine:

00:04:44.996 --> 00:04:47.296 align:middle
Sabemos que se utilizará sobre esta propiedad...
así que será una especie de colección de

00:04:47.616 --> 00:04:51.326 align:middle
DragonTreasures. Pero...

00:04:51.806 --> 00:04:53.936 align:middle
ésta será la colección de

00:04:53.936 --> 00:04:57.726 align:middle
objetosDragonTreasure después de
que hayan sido modificados. Tenemos

00:04:58.486 --> 00:05:01.586 align:middle
que preguntar a Doctrine qué
aspecto tenía cada DragonTreasure

00:05:01.586 --> 00:05:05.226 align:middle
cuando se consultó originalmente en la
base de datos. Para ello, tenemos que coger

00:05:05.846 --> 00:05:11.326 align:middle
un objeto interno de Doctrine
llamado UnitOfWork . Encima,

00:05:12.226 --> 00:05:17.396 align:middle
añade un constructor, autocablea
EntityManagerInterface $entityManager... y

00:05:17.816 --> 00:05:23.736 align:middle
haz que sea una propiedad privada:
Abajo, coge la unidad de trabajo con

00:05:23.736 --> 00:05:29.896 align:middle
$unitOfWork =
$this->entityManager->getUnitOfWork():

00:05:30.756 --> 00:05:35.906 align:middle
Se trata de un potente objeto que realiza un seguimiento
de cómo cambian los objetos de entidad y se encarga

00:05:36.176 --> 00:05:42.066 align:middle
de saber qué objetos deben insertarse,
actualizarse o eliminarse de la

00:05:42.066 --> 00:05:45.236 align:middle
base de datos cuando el gestor de
entidades se vacía. A continuación,

00:05:46.186 --> 00:05:51.516 align:middle
foreach sobre $value - que será una
colección - as $dragonTreasure. Para

00:05:53.186 --> 00:05:54.976 align:middle
ayudar a mi editor, afirmaré que

00:05:54.976 --> 00:05:58.136 align:middle
$dragonTreasure es una
instancia de DragonTreasure. Y

00:05:59.156 --> 00:06:05.006 align:middle
ahora, obtén los datos originales: $originalData =
$unitOfWork->getOriginalEntityData($dragonTreasure). Muy

00:06:05.096 --> 00:06:08.536 align:middle
bonito

00:06:09.696 --> 00:06:10.776 align:middle
, ¿verdad? Vamos a dd($dragonTreasure)

00:06:11.386 --> 00:06:20.206 align:middle
y $originalData para ver qué aspecto
tienen: Go test go: ¡Sí! ¡Ha llegado al

00:06:20.236 --> 00:06:21.016 align:middle
volcado! ¡ Y esto

00:06:21.016 --> 00:06:22.726 align:middle
es genial! La primera

00:06:23.346 --> 00:06:29.626 align:middle
parte es el objeto DragonTreasure actualizado
y su propietario tiene el id 1. No es

00:06:30.556 --> 00:06:37.406 align:middle
super obvio, pero $user será id 1 y
$otherUser será id 2. Así que el propietario

00:06:38.026 --> 00:06:44.386 align:middle
era originalmente id 2, pero sí: ¡el
usuario id 1 lo ha robado! Debajo,

00:06:45.626 --> 00:06:48.566 align:middle
vemos los datos originales como una
matriz. ¡ Y su propietario era el ID 2

00:06:49.256 --> 00:06:51.756 align:middle
! Esta información

00:06:52.626 --> 00:06:55.096 align:middle
nos pone en peligro. De vuelta dentro de

00:06:55.826 --> 00:07:02.476 align:middle
nuestro validador, di $originalOwnerId
= originalData['owner_id']. Y para

00:07:02.476 --> 00:07:10.756 align:middle
que quede superclaro, pon $newOwnerId a
$dragonTreasure->getOwner()->getId(). Si

00:07:11.626 --> 00:07:14.196 align:middle
no coinciden, tenemos un problema.
Bueno, en realidad, si no tenemos

00:07:14.646 --> 00:07:18.496 align:middle
$originalOwnerId, estamos creando

00:07:18.826 --> 00:07:22.216 align:middle
un nuevo DragonTreasure y
no pasa nada. Así que si

00:07:22.866 --> 00:07:25.096 align:middle
no hay $originalOwnerId o el

00:07:25.536 --> 00:07:30.976 align:middle
$originalOwnerId es igual al $newOwnerId
, ¡estamos bien! Si no ... ¡se

00:07:31.766 --> 00:07:34.466 align:middle
está produciendo un saqueo! Mueve el

00:07:35.396 --> 00:07:42.056 align:middle
$violationBuilder hacia arriba, pero
elimina el setParameter() : ¡Ya está! Pero

00:07:42.586 --> 00:07:45.106 align:middle
nunca personalicé el mensaje de error. En la

00:07:45.766 --> 00:07:50.276 align:middle
claseConstraint, dale a la propiedad $message
un mensaje por defecto mejor: Muy bien

00:07:52.516 --> 00:07:54.876 align:middle
equipo, ¡hora de la verdad! Ejecuta la

00:07:55.216 --> 00:07:58.726 align:middle
prueba: ¡Lo he clavado! El robo de tesoros

00:07:59.016 --> 00:08:02.026 align:middle
queda oficialmente descartado. Ah, y

00:08:02.786 --> 00:08:06.976 align:middle
aunque no lo he hecho, también podríamos
inyectar el servicio Security para permitir que

00:08:07.296 --> 00:08:09.976 align:middle
los usuarios administradores hagan
lo que quieran. A continuación:

00:08:10.916 --> 00:08:15.826 align:middle
cuando creamos un DragonTreasure, debemos
enviar el campo owner. Por último,

00:08:16.386 --> 00:08:18.296 align:middle
hagámoslo opcional. Si

00:08:18.956 --> 00:08:22.856 align:middle
no pasamos el owner, lo estableceremos en
el usuario autenticado actualmente. Para

00:08:23.486 --> 00:08:29.186 align:middle
ello, tenemos que engancharnos al proceso de
"guardado" de la API Platform una vez más.
