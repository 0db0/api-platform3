WEBVTT

00:00:01.116 --> 00:00:03.706 align:middle
Tenemos un bonito DragonTreasureResourceTest,

00:00:03.956 --> 00:00:06.066 align:middle
así que vamos a crear uno para el Usuario.

00:00:06.756 --> 00:00:10.316 align:middle
Crea una nueva clase PHP llamada,
qué tal, UserResourceTest.

00:00:12.446 --> 00:00:18.626 align:middle
Haz que extienda nuestro ApiTestCase personalizado
, entonces sólo necesitamos use ResetDatabase:

00:00:19.556 --> 00:00:23.336 align:middle
No necesitamos HasBrowser porque
eso ya está hecho en la clase base.

00:00:23.336 --> 00:00:31.286 align:middle
Empieza con public function testPostToCreateUser()
: Haz una petición de ->post()

00:00:31.286 --> 00:00:42.516 align:middle
a /api/users, añade algo de json con
email y password, y assertStatus(201).

00:00:43.196 --> 00:00:47.726 align:middle
Y ahora que hemos creado el
nuevo usuario, ¡vamos a probar

00:00:47.726 --> 00:00:50.276 align:middle
si podemos iniciar sesión
con sus credenciales!

00:00:50.616 --> 00:00:58.506 align:middle
Haz otra petición ->post() a /login, pasa
también algo de json - copia los email y password

00:00:58.506 --> 00:01:09.016 align:middle
de arriba - y luego assertSuccessful():
Vamos a probarlo: symfony php bin/phpunit

00:01:09.266 --> 00:01:15.106 align:middle
y ejecuta todo el archivo
tests/Functional/UserResourceTest.php:

00:01:16.046 --> 00:01:16.676 align:middle
Y...

00:01:16.896 --> 00:01:20.976 align:middle
¡ok! Un código de estado
422, pero 201 esperado.

00:01:21.606 --> 00:01:25.566 align:middle
Veamos: esto significa que algo
ha ido mal al crear el usuario.

00:01:25.986 --> 00:01:27.666 align:middle
Abramos la última respuesta.

00:01:28.586 --> 00:01:34.666 align:middle
¡Ah! Culpa mía: olvidé pasar el campo obligatorio
username: ¡estamos fallando la validación!

00:01:35.486 --> 00:01:36.456 align:middle
Pasa username...

00:01:36.716 --> 00:01:43.516 align:middle
a cualquier cosa: Inténtalo de
nuevo: Eso es lo que quería:

00:01:43.856 --> 00:01:47.786 align:middle
Esperaba un código de estado
correcto, pero he obtenido 401.

00:01:47.786 --> 00:01:49.966 align:middle
Así que el fallo está aquí abajo.

00:01:50.726 --> 00:01:52.826 align:middle
Pudimos crear el usuario...

00:01:53.246 --> 00:01:56.276 align:middle
pero cuando intentamos iniciar sesión, falló.

00:01:57.056 --> 00:02:00.566 align:middle
Si estuviste con nosotros en el episodio
uno, ¡tal vez recuerdes por qué!

00:02:01.146 --> 00:02:04.846 align:middle
Nunca configuramos nuestra API
para hacer hash de la contraseña.

00:02:05.526 --> 00:02:10.166 align:middle
Compruébalo: dentro de User, sí hicimos
que password formara parte de nuestra API.

00:02:11.126 --> 00:02:14.116 align:middle
El usuario envía la contraseña
en texto plano que quiere...

00:02:14.616 --> 00:02:18.086 align:middle
y luego la guardamos
directamente en la base de datos.

00:02:18.746 --> 00:02:20.996 align:middle
Eso es un enorme problema de seguridad...

00:02:21.296 --> 00:02:25.196 align:middle
y hace imposible iniciar
sesión como este usuario,

00:02:25.526 --> 00:02:29.996 align:middle
porque Symfony espera que la propiedad
password contenga una contraseña con hash.

00:02:29.996 --> 00:02:34.626 align:middle
Así que nuestro objetivo es claro: permitir que
el usuario envíe una contraseña sin formato,

00:02:34.786 --> 00:02:37.556 align:middle
pero luego hashearla antes de
almacenarla en la base de datos.

00:02:38.456 --> 00:02:43.996 align:middle
Para ello, en lugar de almacenar temporalmente la
contraseña en texto plano en la propiedad password, vamos a

00:02:44.286 --> 00:02:50.366 align:middle
crear una propiedad totalmente nueva:
private ?string $plainPassword = null:

00:02:51.216 --> 00:02:55.676 align:middle
Ésta no se almacenará en la base
de datos: es sólo un lugar temporal

00:02:55.676 --> 00:03:01.766 align:middle
para guardar la contraseña en texto plano antes de que le apliquemos
el hash y la establezcamos en la propiedad real password. Abajo del

00:03:02.496 --> 00:03:06.376 align:middle
todo, iré a "Código"->"Generar",
o Command + N en un Mac,

00:03:06.636 --> 00:03:08.956 align:middle
y generaré un "Getter y setter" para esto.

00:03:11.346 --> 00:03:18.976 align:middle
Vamos a limpiar esto un poco: acepta sólo una
cadena, y el PHPDoc es redundante: A continuación,

00:03:18.976 --> 00:03:21.676 align:middle
desplázate hasta la parte
superior y encuentra password.

00:03:22.216 --> 00:03:28.836 align:middle
Elimínalo por completo de nuestra API:
En su lugar, expone plainPassword...

00:03:29.146 --> 00:03:36.586 align:middle
pero utiliza SerializedName para que se llame
password: Obviamente, aún no hemos terminado...

00:03:36.956 --> 00:03:41.436 align:middle
y si ejecutas las pruebas:
¡Las cosas van peor!

00:03:41.786 --> 00:03:44.896 align:middle
Un error 500 debido a una violación no nula.

00:03:45.686 --> 00:03:49.476 align:middle
Estamos enviando password, que
está almacenado en plainPassword...

00:03:49.846 --> 00:03:52.916 align:middle
y no hacemos absolutamente nada con él.

00:03:52.916 --> 00:03:58.246 align:middle
Así que la propiedad real password permanece
nula y explota cuando llega a la base de datos.

00:03:58.246 --> 00:04:03.636 align:middle
Así que ésta es la pregunta del millón: ¿cómo
podemos hacer un hash de la propiedad plainPassword?

00:04:04.246 --> 00:04:11.116 align:middle
O, en términos más sencillos, ¿cómo podemos ejecutar código
en API Platform después de que los datos se deserialicen

00:04:11.416 --> 00:04:14.396 align:middle
pero antes de que se
guarden en la base de datos?

00:04:14.986 --> 00:04:17.776 align:middle
La respuesta es: procesadores de estado.

00:04:18.226 --> 00:04:20.916 align:middle
Vamos a sumergirnos en este
poderoso concepto a continuación.
