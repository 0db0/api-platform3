WEBVTT

00:00:01.066 --> 00:00:03.326 align:middle
Vamos a crear una prueba para
publicar y crear un nuevo tesoro.

00:00:03.326 --> 00:00:08.106 align:middle
Digamos public function
testPostToCreateTreasure() que devuelve void.

00:00:08.726 --> 00:00:14.606 align:middle
Y empezamos igual que antes:
$this->browser()->post('/api/treasures'):

00:00:14.606 --> 00:00:18.076 align:middle
En este caso necesitamos enviar datos.

00:00:18.646 --> 00:00:23.176 align:middle
El segundo argumento de cualquiera de estos
métodos post() o get() es una matriz de opciones,

00:00:23.416 --> 00:00:27.056 align:middle
que puede incluir parámetros
headers, query u otras cosas.

00:00:27.056 --> 00:00:32.546 align:middle
Una clave es json, que puedes establecer en
una matriz, que se codificará en JSON para ti.

00:00:32.546 --> 00:00:34.826 align:middle
Empieza enviando JSON vacío...

00:00:35.316 --> 00:00:38.286 align:middle
y luego ->assertStatus(422).

00:00:38.286 --> 00:00:42.206 align:middle
Para ver cómo es la respuesta,
añade ->dump(): ¡Impresionante!

00:00:42.746 --> 00:00:44.566 align:middle
Copia el nombre del método de prueba.

00:00:44.836 --> 00:00:47.446 align:middle
Quiero centrarme sólo en esta prueba.

00:00:48.096 --> 00:00:56.276 align:middle
Para ello, Ejecuta: symfony php bin/phpunit
--filter=testPostToCreateTreasure Y...

00:00:56.886 --> 00:01:02.416 align:middle
¡oh! El código de estado de respuesta
actual es 401, pero se espera 422.

00:01:03.046 --> 00:01:08.306 align:middle
Cuando una prueba falla con el navegador, guarda
automáticamente la última respuesta en un archivo...

00:01:08.486 --> 00:01:09.636 align:middle
lo cual es genial.

00:01:10.126 --> 00:01:12.176 align:middle
De hecho, está en el directorio var/.

00:01:12.886 --> 00:01:17.736 align:middle
En mi terminal, puedo mantener pulsado Command
y hacer clic para abrirlo en mi navegador.

00:01:18.056 --> 00:01:19.526 align:middle
Eso está muy bien.

00:01:19.956 --> 00:01:21.806 align:middle
Me verás hacer esto un montón de veces.

00:01:22.546 --> 00:01:25.266 align:middle
Vale, esto devuelve un código de estado 401.

00:01:25.726 --> 00:01:29.096 align:middle
Por supuesto: ¡la ruta
requiere autenticación!

00:01:29.686 --> 00:01:35.696 align:middle
Nuestra aplicación tiene dos formas de autenticarse: mediante
el formulario de acceso y la sesión o mediante un token de API.

00:01:36.056 --> 00:01:38.746 align:middle
Vamos a probar ambas, empezando por
el formulario de inicio de sesión.

00:01:39.356 --> 00:01:40.396 align:middle
Para iniciar sesión como usuario...

00:01:40.716 --> 00:01:43.806 align:middle
ese usuario primero tiene que
existir en la base de datos.

00:01:44.486 --> 00:01:48.136 align:middle
Recuerda: al principio de cada prueba,
nuestra base de datos está vacía.

00:01:48.556 --> 00:01:52.116 align:middle
Nuestro trabajo consiste en
llenarla con lo que necesitemos.

00:01:52.946 --> 00:01:58.946 align:middle
Crea un usuario con
UserFactory::createOne(['password' => 'pass'])

00:01:59.236 --> 00:02:01.596 align:middle
para que sepamos cuál será la contraseña.

00:02:02.186 --> 00:02:10.396 align:middle
Luego, antes de hacer la petición POST para crear
un tesoro, ->post() a /login y envía json

00:02:10.746 --> 00:02:13.766 align:middle
con email configurado a $user->getEmail()

00:02:14.286 --> 00:02:19.706 align:middle
-para utilizar cualquier dirección de correo electrónico aleatoria
que Faker haya elegido- y luego password configurado a pass.

00:02:20.606 --> 00:02:23.126 align:middle
Para asegurarnos de que
funcionaba, ->assertStatus(204):

00:02:23.916 --> 00:02:27.496 align:middle
Ese es el código de estado que devolvemos
tras una autenticación correcta.

00:02:28.426 --> 00:02:29.496 align:middle
¡Vamos a probarlo!

00:02:29.886 --> 00:02:33.786 align:middle
Muévete y ejecuta la prueba: ¡Pasa!

00:02:33.786 --> 00:02:38.946 align:middle
¡Obtenemos el código de estado 422
y vemos los mensajes de validación!

00:02:39.326 --> 00:02:41.286 align:middle
Así que... iniciar sesión es...

00:02:41.486 --> 00:02:42.606 align:middle
¡así de fácil!

00:02:42.826 --> 00:02:48.006 align:middle
Y te recomiendo que hagas una prueba que envíe un
POST específico a tu ruta de inicio de sesión,

00:02:48.006 --> 00:02:51.036 align:middle
como acabamos de hacer, para asegurarte
de que funciona correctamente.

00:02:51.716 --> 00:02:54.606 align:middle
Sin embargo, en todas mis otras pruebas...

00:02:54.606 --> 00:03:00.466 align:middle
cuando simplemente necesito autenticarme para hacer el
trabajo real, hay una forma más rápida de iniciar sesión.

00:03:00.466 --> 00:03:08.026 align:middle
En lugar de hacer la petición POST, di
->actingAs($user): Esta es una forma astuta

00:03:08.026 --> 00:03:11.746 align:middle
de tomar el objeto User e
introducirlo directamente

00:03:11.746 --> 00:03:15.986 align:middle
en el sistema de seguridad de
Symfony sin hacer ninguna petición.

00:03:15.986 --> 00:03:17.646 align:middle
Es más fácil y más rápido.

00:03:18.226 --> 00:03:22.916 align:middle
Y ahora, no nos importa en absoluto cuál es
la contraseña, así que podemos simplificarlo.

00:03:23.776 --> 00:03:27.816 align:middle
Vamos a comprobarlo: ¡Sigue bien!

00:03:28.676 --> 00:03:30.056 align:middle
Hagamos otro POST aquí abajo.

00:03:30.656 --> 00:03:32.786 align:middle
Sigue encadenando y añade ->post().

00:03:33.376 --> 00:03:33.896 align:middle
En realidad...

00:03:34.026 --> 00:03:36.676 align:middle
Me da pereza. Copia el
->post() existente ...

00:03:36.956 --> 00:03:37.976 align:middle
y úsalo.

00:03:38.516 --> 00:03:42.896 align:middle
Pero esta vez, envía datos reales:
Teclearé rápidamente algunos...

00:03:43.156 --> 00:03:44.466 align:middle
pueden ser cualquier cosa.

00:03:45.486 --> 00:03:47.216 align:middle
La última clave que necesitamos es owner.

00:03:47.826 --> 00:03:52.066 align:middle
Ahora mismo, estamos obligados a enviar
el owner cuando creamos un tesoro.

00:03:52.536 --> 00:03:59.046 align:middle
Pronto lo haremos opcional: si no lo enviamos,
lo hará por defecto quien esté autentificado.

00:03:59.686 --> 00:04:05.096 align:middle
Pero por ahora, ponlo en /api/users/
y luego en $user->getId().

00:04:05.096 --> 00:04:13.446 align:middle
Termina con assertStatus(201): Porque 201 es lo
que devuelve la API cuando se crea un objeto.

00:04:14.216 --> 00:04:18.326 align:middle
Muy bien, a probar: ¡Sigue pasando!

00:04:18.716 --> 00:04:19.436 align:middle
¡Estamos en racha!

00:04:20.286 --> 00:04:24.946 align:middle
Añade un ->dump() para ayudarnos a depurar y luego
una comprobación de cordura: ->assertJsonMatches()

00:04:25.346 --> 00:04:33.766 align:middle
que name es A shiny thing: Cuando lo
probemos Ninguna sorpresa: todo verde.

00:04:34.246 --> 00:04:37.916 align:middle
Pero mira la respuesta
volcada: ¡no es JSON-LD!

00:04:37.916 --> 00:04:40.866 align:middle
Nos devuelve JSON estándar.

00:04:41.366 --> 00:04:45.066 align:middle
Puedes verlo en la cabecera
Content-Type: 'application/json',

00:04:45.256 --> 00:04:50.456 align:middle
no application/ld+json, que es
lo que esperaba. Averigüemos

00:04:50.456 --> 00:04:54.806 align:middle
qué está pasando y
solucionémoslo globalmente

00:04:54.806 --> 00:04:59.016 align:middle
personalizando el funcionamiento del
Navegador en todo nuestro conjunto de pruebas.
