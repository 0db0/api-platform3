WEBVTT

00:00:01.026 --> 00:00:04.026 align:middle
Hagamos que esta prueba sea
real con datos y aserciones.

00:00:04.456 --> 00:00:06.636 align:middle
Hay dos formas principales de
hacer aserciones con el Navegador.

00:00:07.316 --> 00:00:11.766 align:middle
En primer lugar, viene con un montón de métodos
integrados para ayudarte, como ->assertJson().

00:00:12.216 --> 00:00:15.746 align:middle
O... siempre puedes coger el
JSON que vuelve de una ruta

00:00:15.966 --> 00:00:20.536 align:middle
y comprobar las cosas utilizando las aserciones
incorporadas de PHPUnit que conoces y adoras.

00:00:20.886 --> 00:00:21.936 align:middle
Veremos ambas cosas.

00:00:22.496 --> 00:00:27.506 align:middle
Empecemos comprobando ->assertJson():
Cuando lo ejecutamos: ¡Pasa!

00:00:27.846 --> 00:00:33.796 align:middle
¡Genial! Sabemos que esta respuesta debe tener
una propiedad hydra:totalItems establecida

00:00:33.796 --> 00:00:35.026 align:middle
al número de resultados.

00:00:35.856 --> 00:00:38.026 align:middle
Ahora mismo, nuestra base
de datos está vacía...

00:00:38.196 --> 00:00:40.726 align:middle
pero al menos podemos afirmar
que coincide con cero.

00:00:41.516 --> 00:00:44.986 align:middle
Para ello, utiliza ->assertJsonMatches().

00:00:45.796 --> 00:00:50.996 align:middle
Se trata de un método especial de Browser que
utiliza una sintaxis especial que nos permite

00:00:50.996 --> 00:00:53.226 align:middle
leer diferentes partes del JSON.

00:00:53.726 --> 00:00:55.196 align:middle
Profundizaremos en ello dentro de un minuto.

00:00:55.656 --> 00:00:57.246 align:middle
Pero éste es sencillo: afirma

00:00:57.246 --> 00:01:04.536 align:middle
que hydra:totalItems es igual a
0: Cuando lo intentamos: ¡Falla!

00:01:04.696 --> 00:01:10.286 align:middle
Pero con un gran error:
mtdowling/jmespath.php es necesario

00:01:10.286 --> 00:01:13.576 align:middle
para buscar en JSON ¡Ah,
tenemos que instalarlo!

00:01:14.356 --> 00:01:17.656 align:middle
Copia la línea composer require,
busca tu terminal y ejecútalo:

00:01:19.246 --> 00:01:24.516 align:middle
Esto de "JMESPath" es en realidad
superguay: es un "lenguaje de consulta"

00:01:24.516 --> 00:01:26.866 align:middle
para leer distintas partes de cualquier JSON.

00:01:27.396 --> 00:01:34.196 align:middle
Por ejemplo, si éste es tu JSON y quieres leer
la clave a, sólo tienes que decir a. Sencillo.

00:01:34.716 --> 00:01:45.366 align:middle
Pero también puedes hacer cosas más profundas, como
a.b.c.d. O ponte más loco: coge el índice 1, o coge a.b.c,

00:01:45.416 --> 00:01:50.496 align:middle
luego el índice 0, .d, el
índice 1 y luego el índice 0.

00:01:51.006 --> 00:01:53.716 align:middle
Incluso puedes trocear la
matriz de diferentes maneras.

00:01:54.266 --> 00:01:54.816 align:middle
Básicamente...

00:01:55.016 --> 00:01:55.976 align:middle
puedes volverte loco.

00:01:56.416 --> 00:01:58.826 align:middle
Pero no vamos a perder la cabeza con esto.

00:01:59.296 --> 00:02:00.716 align:middle
Es una sintaxis práctica...

00:02:00.996 --> 00:02:06.566 align:middle
pero si las cosas se ponen demasiado complejas, siempre podemos
probar el JSON manualmente, cosa que haremos dentro de un rato.

00:02:07.486 --> 00:02:11.556 align:middle
De todos modos, ahora que tenemos la biblioteca
instalada, volvamos a ejecutar la prueba.

00:02:12.826 --> 00:02:14.366 align:middle
¡Sigue fallando!

00:02:14.366 --> 00:02:20.896 align:middle
Con un extraño error Error de sintaxis
en el carácter 5 hydra:totalItems.

00:02:21.556 --> 00:02:27.106 align:middle
Por desgracia, el : es un carácter
especial dentro de JMESPath.

00:02:27.756 --> 00:02:31.426 align:middle
Así que siempre que tengamos un :, tenemos
que poner comillas alrededor de esa clave:

00:02:31.956 --> 00:02:34.716 align:middle
No es lo ideal, pero no
es un gran inconveniente.

00:02:35.556 --> 00:02:38.886 align:middle
Ahora, cuando lo probamos ¡Pasa!

00:02:39.356 --> 00:02:45.096 align:middle
Pero... no es una prueba muy interesante: sólo
estamos afirmando que no nos devuelve nada...

00:02:45.216 --> 00:02:46.926 align:middle
porque la base de datos está vacía.

00:02:47.826 --> 00:02:52.966 align:middle
Para que nuestra prueba sea real, necesitamos
datos: necesitamos sembrar la base de datos

00:02:52.966 --> 00:02:54.706 align:middle
con datos al inicio de la prueba.

00:02:55.326 --> 00:02:58.796 align:middle
Afortunadamente, Foundry lo
hace muy sencillo. Arriba,

00:03:00.256 --> 00:03:05.566 align:middle
llama a DragonTreasureFactory::createMany()
y creemos 5 tesoros.

00:03:06.086 --> 00:03:12.126 align:middle
Ahora, abajo, afirma que obtenemos
5 resultados: Así de sencillo.

00:03:12.726 --> 00:03:21.126 align:middle
Y, de hecho, déjame que vuelva a poner nuestro volcado
para que podamos ver el resultado: Pruébalo ahora: ¡Pasa!

00:03:21.656 --> 00:03:23.316 align:middle
Y si miras hacia arriba, ¡sí!

00:03:23.816 --> 00:03:26.056 align:middle
¡La respuesta tiene 5 tesoros!

00:03:26.506 --> 00:03:27.486 align:middle
Vaya, ha sido fácil.

00:03:28.286 --> 00:03:31.896 align:middle
A continuación: utilicemos JMESPath
para afirmar algo más desafiante.

00:03:32.526 --> 00:03:37.426 align:middle
Luego retrocederemos y veremos cómo podemos profundizar en
Browser para darnos una flexibilidad -y simplicidad- infinitas a la

00:03:37.686 --> 00:03:40.666 align:middle
hora de probar JSON.
