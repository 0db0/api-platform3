WEBVTT

00:00:01.056 --> 00:00:05.316 align:middle
Hemos dejado de devolver tesoros no publicados
desde el punto final de la colección de tesoros,

00:00:05.546 --> 00:00:09.376 align:middle
pero aún puedes recuperarlos desde
el punto final GET uno. Esto se

00:00:09.756 --> 00:00:13.876 align:middle
debe a que estas clases
QueryCollectionExtensionInterface sólo se

00:00:13.876 --> 00:00:19.736 align:middle
invocan cuando obtenemos una colección de elementos,
no cuando seleccionamos un único elemento.

00:00:20.586 --> 00:00:22.606 align:middle
Para comprobarlo, entra en nuestra prueba.

00:00:23.716 --> 00:00:33.076 align:middle
Duplica la prueba de la colección, pégala y
llámala testGetOneUnpublishedTreasure404s().

00:00:33.076 --> 00:00:36.966 align:middle
Dentro, crea sólo un DragonTreasure
que no esté publicado...

00:00:36.966 --> 00:00:40.816 align:middle
y haz una petición ->get()
a /api/treasures/...

00:00:41.156 --> 00:00:43.906 align:middle
¡oh! Necesito una variable $dragonTreasure.

00:00:45.286 --> 00:00:45.966 align:middle
Eso está mejor.

00:00:46.356 --> 00:00:48.536 align:middle
Ahora añade $dragonTreasure->getId().

00:00:49.546 --> 00:00:53.266 align:middle
En la parte inferior, afirma
que el estado es 404...

00:00:53.916 --> 00:01:01.366 align:middle
y no necesitamos ninguna de estas afirmaciones,
ni esta variable $json: ¡Muy sencillo!

00:01:01.826 --> 00:01:04.696 align:middle
Coge ese nombre de método y,
ya sabes lo que hay que hacer.

00:01:05.086 --> 00:01:07.896 align:middle
Ejecuta sólo esa prueba: Y...

00:01:07.896 --> 00:01:11.206 align:middle
¡sí! Actualmente devuelve
un código de estado 200.

00:01:11.756 --> 00:01:13.036 align:middle
¿Cómo lo arreglamos?

00:01:13.686 --> 00:01:18.206 align:middle
Bueno... igual que hay un
QueryCollectionExtensionInterface

00:01:18.206 --> 00:01:24.906 align:middle
para la ruta de la colección, también hay un
QueryItemExtensionInterface que se utiliza siempre que la API

00:01:24.906 --> 00:01:27.766 align:middle
Platform consulta un único elemento.

00:01:28.486 --> 00:01:30.706 align:middle
Puedes crear una clase totalmente
independiente para esto...

00:01:30.856 --> 00:01:32.556 align:middle
pero también puedes combinarlas.

00:01:33.186 --> 00:01:36.676 align:middle
Añade una segunda interfaz para
QueryItemExtensionInterface.

00:01:37.246 --> 00:01:41.796 align:middle
Luego, desplázate hacia abajo y ve a
"Código"->"Generar" -o Command + N en un Mac-

00:01:42.016 --> 00:01:46.596 align:middle
para añadir el único método que
nos falta: applyToItem(): Sí, es

00:01:46.856 --> 00:01:49.776 align:middle
casi idéntico al método de recolección....

00:01:50.096 --> 00:01:51.576 align:middle
funciona de la misma manera...

00:01:52.006 --> 00:01:54.246 align:middle
¡e incluso necesitamos la misma lógica!

00:01:54.586 --> 00:02:00.876 align:middle
Así que, copia el código que necesitamos, luego
ve al menú Refactorizar y di "Refactorizar esto",

00:02:00.946 --> 00:02:03.386 align:middle
que también es Control + T en un Mac.

00:02:04.296 --> 00:02:06.196 align:middle
Selecciona extraer esto a un método...

00:02:06.626 --> 00:02:10.736 align:middle
y llámalo addIsPublishedWhere():
¡Impresionante!

00:02:11.326 --> 00:02:12.246 align:middle
Limpiaré las cosas...

00:02:12.756 --> 00:02:14.036 align:middle
y, ¿sabes qué?

00:02:14.296 --> 00:02:17.226 align:middle
Debería haber añadido también
esta declaración if ahí dentro.

00:02:17.786 --> 00:02:23.406 align:middle
Así que vamos a mover eso: Lo que significa que
necesitamos un argumento string $resourceClass.

00:02:24.716 --> 00:02:28.976 align:middle
Arriba, pasa $resourceClass
al método: ¡Perfecto!

00:02:29.486 --> 00:02:35.536 align:middle
Ahora, en applyToItem(), llama a ese
mismo mé todo: Vale, ¡ya estamos listos!

00:02:36.146 --> 00:02:38.946 align:middle
Intenta ahora la prueba: Y...

00:02:39.626 --> 00:02:40.926 align:middle
¡pasa!

00:02:41.486 --> 00:02:46.866 align:middle
Hemos estado retocando bastante nuestro
código, ¡así que es hora de probarlo!

00:02:47.216 --> 00:02:53.606 align:middle
Ejecuta todas las pruebas:
symfony php bin/phpunit Y...

00:02:54.026 --> 00:02:59.076 align:middle
¡Uy! 3 fallos, todos procedentes
de DragonTreasureResourceTest.

00:03:00.086 --> 00:03:05.346 align:middle
El problema es que, cuando creamos tesoros
en nuestras pruebas, no fuimos explícitos

00:03:05.346 --> 00:03:09.066 align:middle
sobre si queríamos un tesoro
publicado o no publicado...

00:03:09.556 --> 00:03:12.566 align:middle
y ese valor se establece
aleatoriamente en nuestra fábrica.

00:03:12.566 --> 00:03:19.346 align:middle
Para solucionarlo, podríamos ser explícitos
controlando el campo isPublished cada vez que creamos

00:03:19.346 --> 00:03:19.796 align:middle
un tesoro.

00:03:20.406 --> 00:03:27.306 align:middle
O... podemos ser más perezosos y, en DragonTreasureFactory,
establecer isPublished como verdadero por defecto:

00:03:27.306 --> 00:03:31.266 align:middle
Ahora, para que nuestros datos
fijos sigan siendo interesantes,

00:03:31.696 --> 00:03:36.276 align:middle
cuando creemos los 40 tesoros
de dragón, anulemos isPublished

00:03:36.536 --> 00:03:42.866 align:middle
y añadamos manualmente algo de aleatoriedad: si
un número aleatorio de 0 a 10 es mayor que 3,

00:03:43.486 --> 00:03:47.866 align:middle
que se publique: Eso debería arreglar
la mayoría de nuestras pruebas.

00:03:48.156 --> 00:03:50.476 align:middle
Aunque busca unpublished.

00:03:50.976 --> 00:03:55.736 align:middle
Ah sí, estamos probando que un admin
puede PATCH para editar un tesoro.

00:03:56.456 --> 00:03:59.196 align:middle
Creamos un DragonTreasure no publicado ...

00:03:59.446 --> 00:04:02.436 align:middle
sólo para poder afirmar que
esto estaba en la respuesta.

00:04:02.886 --> 00:04:08.846 align:middle
Cambiemos esto a true en ambos
sitios: Hay otra prueba similar:

00:04:09.356 --> 00:04:20.406 align:middle
cambia aquí también isPublished por true:
Ahora prueba las pruebas: ¡Están contentos!

00:04:20.816 --> 00:04:21.656 align:middle
¡Yo estoy contento!

00:04:22.016 --> 00:04:23.106 align:middle
Bueno, casi.

00:04:23.726 --> 00:04:25.686 align:middle
Aún tenemos un problemilla.

00:04:25.686 --> 00:04:27.816 align:middle
Encuentra la primera prueba de PATCH.

00:04:28.456 --> 00:04:31.956 align:middle
Estamos creando un DragonTreasure
publicado, actualizándolo...

00:04:32.476 --> 00:04:34.766 align:middle
y funciona perfectamente.

00:04:34.766 --> 00:04:36.086 align:middle
Copia toda esta prueba...

00:04:37.046 --> 00:04:37.576 align:middle
pégala..

00:04:37.956 --> 00:04:40.416 align:middle
pero borra la parte inferior: sólo
necesitamos la parte superior.

00:04:43.346 --> 00:04:46.966 align:middle
Llama a este método
testPatchUnpublishedWorks()...

00:04:48.056 --> 00:04:53.616 align:middle
y asegúrate de que DragonTreasure
no está publicado: Piénsalo

00:04:54.056 --> 00:05:00.976 align:middle
si tengo un DragonTreasure con isPublished
false , debería poder actualizarlo, ¿no?

00:05:01.616 --> 00:05:03.026 align:middle
Este es mi tesoro...

00:05:03.256 --> 00:05:06.686 align:middle
Yo lo creé y sigo trabajando en él.

00:05:07.016 --> 00:05:08.576 align:middle
Queremos que se permita.

00:05:09.116 --> 00:05:13.206 align:middle
¿Lo estará? Probablemente
puedes adivinarlo: ¡No!

00:05:13.356 --> 00:05:14.726 align:middle
¡Obtendremos un 404!

00:05:15.286 --> 00:05:16.976 align:middle
Esto es tanto una característica...

00:05:17.256 --> 00:05:18.566 align:middle
¡y un "gotcha"! Cuando creamos

00:05:19.156 --> 00:05:22.236 align:middle
un QueryCollectionExtensionInterface,

00:05:22.556 --> 00:05:25.546 align:middle
sólo se utiliza para esta
única ruta de recogida.

00:05:26.156 --> 00:05:32.306 align:middle
Pero cuando creamos un ItemExtensionInterface, se
utiliza siempre que obtenemos un único tesoro:

00:05:32.756 --> 00:05:36.746 align:middle
incluso para las operaciones
Delete, Patch y Put.

00:05:37.486 --> 00:05:40.836 align:middle
Así que, cuando un propietario intenta
Patch su propio DragonTreasure , gracias

00:05:40.836 --> 00:05:44.506 align:middle
a nuestra extensión de
consulta, no puede encontrarlo.

00:05:45.386 --> 00:05:46.776 align:middle
Esto tiene dos soluciones.

00:05:46.776 --> 00:05:52.116 align:middle
En primer lugar, en applyToItem(),
API Platform nos pasa el $operation.

00:05:52.116 --> 00:05:57.586 align:middle
Así que podríamos utilizarlo para determinar
si se trata de una operación Get, Patch o Delete

00:05:57.996 --> 00:06:01.076 align:middle
y aplicar la lógica sólo
para algunas de ellas.

00:06:01.516 --> 00:06:03.176 align:middle
Y... esto podría tener sentido.

00:06:03.596 --> 00:06:07.726 align:middle
Al fin y al cabo, si puedes
editar o borrar un tesoro...

00:06:08.026 --> 00:06:10.676 align:middle
eso significa que ya has pasado
una comprobación de seguridad...

00:06:11.156 --> 00:06:15.766 align:middle
así que no necesitamos necesariamente bloquear
las cosas mediante esta extensión de consulta.

00:06:16.556 --> 00:06:21.076 align:middle
La otra solución es cambiar la consulta para permitir
que los propietarios vean sus propios tesoros.

00:06:21.686 --> 00:06:26.756 align:middle
Lo bueno de esta solución es que también
permitirá que se devuelvan tesoros no publicados

00:06:26.756 --> 00:06:32.516 align:middle
desde la ruta de recogida si el usuario
actual es el propietario de ese tesoro.

00:06:34.116 --> 00:06:35.046 align:middle
Vamos a intentarlo.

00:06:35.456 --> 00:06:37.006 align:middle
Añade el public function __construct()...

00:06:37.746 --> 00:06:42.246 align:middle
y autocablea el increíble servicio
Security: A continuación...

00:06:42.516 --> 00:06:43.936 align:middle
la vida se complica un poco.

00:06:44.936 --> 00:06:48.566 align:middle
Empieza con $user =
$this->security->getUser().

00:06:49.316 --> 00:06:53.526 align:middle
Si tenemos un usuario, vamos a modificar
el QueryBuilder de forma similar...

00:06:53.526 --> 00:06:57.626 align:middle
pero de forma ligeramente distinta.

00:06:57.626 --> 00:07:01.946 align:middle
En realidad, déjame subir el $rootAlias
por encima de mi sentencia if.

00:07:02.936 --> 00:07:09.736 align:middle
Ahora, si el usuario está conectado,
añade OR %s.owner = :owner...

00:07:10.426 --> 00:07:12.866 align:middle
luego pasa otro rootAlias...

00:07:12.866 --> 00:07:17.886 align:middle
seguido de ->setParameter('owner', $user).

00:07:20.086 --> 00:07:23.556 align:middle
En caso contrario, si no hay usuario,
utiliza la consulta original.

00:07:25.216 --> 00:07:28.436 align:middle
Y necesitamos el parámetro
isPublished en ambos casos...

00:07:28.526 --> 00:07:33.786 align:middle
así que mantenlo al
final: ¡Creo que me gusta!

00:07:34.216 --> 00:07:38.646 align:middle
Veamos qué opina el test: ¡También le gusta!

00:07:39.606 --> 00:07:42.276 align:middle
De hecho, todas nuestras
pruebas parecen contentas.

00:07:43.026 --> 00:07:44.876 align:middle
Ok equipo: tema final.

00:07:45.556 --> 00:07:49.236 align:middle
Cuando obtenemos un recurso User,
devolvemos sus tesoros dragón.

00:07:49.846 --> 00:07:53.676 align:middle
¿Esa colección incluye
también tesoros inéditos?

00:07:54.226 --> 00:07:56.076 align:middle
Ah... ¡sí!

00:07:56.546 --> 00:07:59.126 align:middle
Hablemos de por qué y de cómo
solucionarlo a continuación.
