WEBVTT

00:00:00.036 --> 00:00:06.366 align:middle
Si necesitas controlar cómo se establece un campo
como isPublished en función de quién está conectado,

00:00:06.616 --> 00:00:08.346 align:middle
tienes dos situaciones diferentes.

00:00:08.346 --> 00:00:12.076 align:middle
En primer lugar, si necesitas impedir
totalmente que determinados usuarios escriban

00:00:12.076 --> 00:00:15.516 align:middle
en este campo, para eso está la seguridad.

00:00:16.116 --> 00:00:20.056 align:middle
La opción más sencilla es utilizar
la opción # [ApiProperty(security:

00:00:20.056 --> 00:00:22.566 align:middle
...)] que hemos utilizado
antes encima de la propiedad.

00:00:23.246 --> 00:00:29.046 align:middle
O podrías ponerte más elegante y añadir un grupo
dinámico admin:write mediante un constructor de contexto.

00:00:29.676 --> 00:00:33.846 align:middle
De cualquier forma, impediremos que
este campo se escriba por completo.

00:00:34.566 --> 00:00:38.936 align:middle
La segunda situación es cuando a un usuario
se le debe permitir escribir en un campo...

00:00:39.356 --> 00:00:43.696 align:middle
pero los datos válidos que se les permite
establecer dependen de quién sean.

00:00:44.196 --> 00:00:48.476 align:middle
Por ejemplo, un usuario puede
escribir isPublished en false...

00:00:48.896 --> 00:00:52.846 align:middle
pero no puede poner true a
menos que sea un administrador.

00:00:53.776 --> 00:00:55.146 align:middle
Te daré un ejemplo diferente.

00:00:55.786 --> 00:01:00.756 align:middle
Ahora mismo, cuando creas un DragonTreasure,
obligamos al cliente a pasar un owner.

00:01:01.456 --> 00:01:04.206 align:middle
Podemos ver esto en testPostToCreateTreasure().

00:01:04.986 --> 00:01:09.996 align:middle
Vamos a arreglarlo en unos minutos para
que podamos dejar este campo desactivado...

00:01:09.996 --> 00:01:13.916 align:middle
y entonces se establecerá
automáticamente para quien se autentique.

00:01:14.416 --> 00:01:18.276 align:middle
Pero ahora mismo, el campo owner
está permitido y es obligatorio.

00:01:18.826 --> 00:01:24.006 align:middle
Pero a quién se permite asignar como
owner depende de quién esté conectado.

00:01:24.006 --> 00:01:29.756 align:middle
Para los usuarios normales, sólo se les debería
permitir asignarse a sí mismos como usuario.

00:01:29.756 --> 00:01:34.196 align:middle
Pero para los administradores, deberían
poder asignar a cualquiera como owner.

00:01:34.876 --> 00:01:40.246 align:middle
Diablos, quizá en el futuro nos volvamos
más locos y haya clanes de dragones...

00:01:40.576 --> 00:01:45.696 align:middle
y puedas crear tesoros y asignarlos a
cualquiera de tu clan La cuestión es:

00:01:45.956 --> 00:01:52.276 align:middle
la cuestión no es si podemos establecer este campo,
sino a qué datos se nos permite establecerlo.

00:01:52.276 --> 00:01:54.266 align:middle
Y eso depende de quiénes seamos.

00:01:55.096 --> 00:02:00.036 align:middle
Vale, en realidad, este problema lo hemos
resuelto antes para la operación Patch().

00:02:00.786 --> 00:02:01.306 align:middle
Déjame que te lo muestre.

00:02:01.306 --> 00:02:04.266 align:middle
Busca testPatchToUpdateTreasure().

00:02:04.986 --> 00:02:10.366 align:middle
Entonces... vamos a ejecutar
sólo esa prueba: Y...

00:02:10.966 --> 00:02:12.036 align:middle
pasa.

00:02:12.996 --> 00:02:15.076 align:middle
Esta prueba comprueba 3 cosas.

00:02:15.076 --> 00:02:20.476 align:middle
En primer lugar, nos conectamos como el usuario propietario
de DragonTreasure y realizamos una actualización.

00:02:21.116 --> 00:02:22.726 align:middle
¡Ese es el caso feliz!

00:02:23.226 --> 00:02:29.066 align:middle
A continuación, entramos como un usuario diferente e
intentamos editar el DragonTreasure del primer usuario.

00:02:29.386 --> 00:02:31.146 align:middle
Eso no está permitido.

00:02:31.586 --> 00:02:35.526 align:middle
Y ése es un uso correcto de security: no
somos propietarios de este DragonTreasure,

00:02:35.526 --> 00:02:38.416 align:middle
por lo que no se nos permite
en absoluto editarlo.

00:02:38.786 --> 00:02:41.046 align:middle
Eso es lo que protege la línea security.

00:02:41.046 --> 00:02:46.056 align:middle
Para la última parte, nos registramos de
nuevo como propietarios de este DragonTreasure.

00:02:46.406 --> 00:02:49.836 align:middle
Pero luego intentamos cambiar
el propietario por otra persona.

00:02:50.306 --> 00:02:55.216 align:middle
Eso tampoco está permitido y ésta es
la situación de la que estamos hablando.

00:02:55.716 --> 00:02:58.866 align:middle
Actualmente se gestiona con
securityPostDenormalize().

00:02:59.286 --> 00:03:02.366 align:middle
Pero en su lugar quiero
gestionarlo con la validación.

00:03:02.986 --> 00:03:09.916 align:middle
¿Por qué? Porque la pregunta a la que estamos respondiendo es
la siguiente: ¿Son válidos los datos de owner que se envían?

00:03:10.236 --> 00:03:12.376 align:middle
Y... validar los datos es...

00:03:12.646 --> 00:03:14.096 align:middle
¡el trabajo de la validación!

00:03:14.836 --> 00:03:16.906 align:middle
Elimina el securityPostDenormalize():

00:03:17.216 --> 00:03:22.386 align:middle
Y para demostrar que esto era importante,
vuelve a ejecutar la prueba: ¡Sí!

00:03:22.686 --> 00:03:24.666 align:middle
Falló en la línea 132...

00:03:25.756 --> 00:03:27.436 align:middle
que es ésta de aquí abajo.

00:03:28.096 --> 00:03:32.296 align:middle
Vamos a reescribir esto con un validador
personalizado, que en realidad es mucho más bonito.

00:03:32.996 --> 00:03:40.396 align:middle
Ah, pero como esto fallará por validación
cuando acabemos, cambia a assertStatus(422):

00:03:40.396 --> 00:03:46.206 align:middle
La idea es que estamos autorizados a PATCH este
usuario, pero hemos enviado datos no válidos:

00:03:46.556 --> 00:03:49.576 align:middle
no podemos establecer este propietario
a alguien que no seamos nosotros mismos.

00:03:50.486 --> 00:03:52.766 align:middle
Vale, dirígete a la línea de
comandos y ejecuta: php ./bin/console

00:03:52.766 --> 00:03:58.806 align:middle
make:validator Dale un nombre chulo
como IsValidOwnerValidator. En

00:03:59.826 --> 00:04:02.806 align:middle
Symfony, los validadores son
dos clases diferentes. Abre

00:04:03.256 --> 00:04:06.276 align:middle
primerosrc/Validator/IsValidOwner.php: Esta

00:04:06.956 --> 00:04:09.946 align:middle
clase ligera se utilizará como atributo... y

00:04:10.186 --> 00:04:16.376 align:middle
sólo contiene opciones que podemos
configurar, como $message, que es suficiente.

00:04:16.376 --> 00:04:24.156 align:middle
Cambiemos el mensaje por defecto por algo un
poco más útil: La segunda clase es la que se

00:04:24.156 --> 00:04:28.846 align:middle
ejecutará para manejar la lógica: Lo
veremos dentro de un momento... pero

00:04:29.326 --> 00:04:31.506 align:middle
antes utilicemos la nueva restricción. Sobre

00:04:32.426 --> 00:04:35.696 align:middle
DragonTreasure, abajo en
la propiedad owner... ahí

00:04:36.126 --> 00:04:36.726 align:middle
vamos... añade

00:04:37.216 --> 00:04:44.306 align:middle
el nuevo atributo: IsValidOwner: Ahora que tenemos
esto, cuando se valide nuestro objeto, Symfony

00:04:44.556 --> 00:04:51.306 align:middle
llamará a IsValidOwnerValidator y nos pasará
el $value -que será el objeto User - y

00:04:51.816 --> 00:04:55.336 align:middle
la restricción, que será
IsValidOwner. Hagamos

00:04:56.216 --> 00:04:57.346 align:middle
un poco de limpieza. Elimina

00:04:57.796 --> 00:05:03.376 align:middle
el var y sustitúyelo por assert($constraint
instanceof IsValidOwner) : Es

00:05:04.116 --> 00:05:08.546 align:middle
sólo para ayudar a mi editor: sabemos que
Symfony siempre nos pasará eso. A continuación,

00:05:09.256 --> 00:05:14.796 align:middle
fíjate en que comprueba si
$value es nulo o está vacío. Y

00:05:14.796 --> 00:05:17.256 align:middle
si lo es, no hace nada. Si la

00:05:17.256 --> 00:05:23.046 align:middle
propiedad $owner está vacía, eso sí que debería
gestionarlo una restricción diferente. De vuelta en

00:05:23.956 --> 00:05:30.066 align:middle
DragonTreasure, añade #[Assert\NotNull]:
Así, si se olvidan de enviar owner, esto se

00:05:30.286 --> 00:05:32.446 align:middle
encargará de ese error de
validación. De vuelta dentro de

00:05:33.176 --> 00:05:38.936 align:middle
nuestro validador, si nos encontramos en esa situación,
podemos simplemente devolver: Debajo de esto, añade

00:05:39.216 --> 00:05:43.226 align:middle
un assert() más que $value es
un instanceof User. Realmente,

00:05:44.066 --> 00:05:48.506 align:middle
Symfony nos pasará cualquier valor
que se adjunte a esta propiedad... pero

00:05:48.826 --> 00:05:54.306 align:middle
sabemos que siempre será un User:
Finalmente, elimina setParameter() - que

00:05:54.576 --> 00:05:56.386 align:middle
no es necesario en nuestro caso - y

00:05:57.026 --> 00:06:00.776 align:middle
$constraint->message está leyendo
la propiedad $message: Llegados

00:06:01.826 --> 00:06:04.566 align:middle
a este punto, ¡tenemos un
validador funcional! Salvo que...

00:06:04.886 --> 00:06:08.646 align:middle
que va a fallar en todas las situaciones. Ah,

00:06:09.296 --> 00:06:11.656 align:middle
al menos asegurémonos de que
está siendo llamado. Ejecuta

00:06:12.256 --> 00:06:16.566 align:middle
nuestra prueba: ¡Bonito fallo! Un

00:06:16.566 --> 00:06:21.726 align:middle
422 procedente de la línea 110 de
DragonTreasureResourceTest... porque

00:06:22.086 --> 00:06:24.866 align:middle
nuestra restricción nunca
se satisface. Por último,

00:06:24.866 --> 00:06:28.276 align:middle
podemos añadir nuestra
lógica de negocio. Para

00:06:28.856 --> 00:06:31.686 align:middle
hacer la comprobación del propietario,
necesitamos saber quién está conectado. Añade

00:06:33.086 --> 00:06:36.846 align:middle
un método __construct(), autocablea
nuestra clase favorita Security... y

00:06:37.566 --> 00:06:42.116 align:middle
pondré private delante, para que se
convierta en una propiedad: Abajo, pon

00:06:42.116 --> 00:06:45.806 align:middle
$user = $this->security->getUser(). Y

00:06:45.806 --> 00:06:53.376 align:middle
si no hay usuario por alguna razón, lanza un
LogicException para que las cosas exploten: ¿Por qué

00:06:54.446 --> 00:06:56.436 align:middle
no lanzar un error de validación?

00:06:57.046 --> 00:06:58.116 align:middle
Podríamos... pero

00:06:58.326 --> 00:07:04.646 align:middle
en nuestra aplicación, si un usuario anónimo está
cambiando de alguna manera con éxito un DragonTreasure...

00:07:05.046 --> 00:07:07.236 align:middle
tenemos algún tipo de error
de configuración. Por último,

00:07:07.236 --> 00:07:13.766 align:middle
si $value no es igual a $user -o
sea, si owner no es User -, añade

00:07:14.096 --> 00:07:17.686 align:middle
ese fallo de validación:
¡Ya está! ¡ Vamos a

00:07:17.976 --> 00:07:18.836 align:middle
probar esto! Y...

00:07:19.886 --> 00:07:21.596 align:middle
¡bingo! Tanto si

00:07:22.056 --> 00:07:26.486 align:middle
estamos creando como editando un
DragonTreasure, no se nos permite

00:07:26.486 --> 00:07:29.646 align:middle
establecer como propietario a
alguien que no seamos nosotros. Y

00:07:30.266 --> 00:07:32.816 align:middle
podemos añadir cualquier otra
fantasía que queramos. Por ejemplo,

00:07:33.356 --> 00:07:40.636 align:middle
si el usuario es un administrador, volver
para que los usuarios administradores puedan

00:07:40.636 --> 00:07:44.976 align:middle
asignar el owner a cualquiera:
esto me encanta. Pero...

00:07:45.356 --> 00:07:50.686 align:middle
sigue habiendo un gran agujero de seguridad:
¡un agujero que permitirá a un usuario

00:07:50.686 --> 00:07:53.556 align:middle
robar los tesoros de otra persona! ¡ No

00:07:53.916 --> 00:07:58.006 align:middle
mola! Averigüemos cuál es a
continuación y aplastémoslo.
