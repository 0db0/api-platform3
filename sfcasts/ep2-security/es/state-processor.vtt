WEBVTT

00:00:01.076 --> 00:00:04.196 align:middle
Cuando un cliente de la API crea un
usuario, envía un campo password,

00:00:04.386 --> 00:00:06.706 align:middle
que se establece en la propiedad plainPassword.

00:00:07.316 --> 00:00:11.946 align:middle
Ahora, necesitamos hacer un hash de esa contraseña
antes de que User se guarde en la base de datos.

00:00:12.686 --> 00:00:16.616 align:middle
Como demostramos al trabajar con Foundry,
hacer hash de una contraseña es sencillo:

00:00:17.086 --> 00:00:23.666 align:middle
coge el servicio UserPasswordHasherInterface y luego
llama a un método sobre él: Pero para conseguirlo,

00:00:23.826 --> 00:00:30.306 align:middle
necesitamos un "gancho" en la API Platform : necesitamos alguna forma
de ejecutar código después de que nuestros datos se deserialicen

00:00:30.306 --> 00:00:33.566 align:middle
en el objeto User, pero
antes de que se guarden.

00:00:34.176 --> 00:00:38.866 align:middle
En nuestro tutorial sobre la API Platform 2,
utilizamos para ello una escucha Doctrine,

00:00:38.866 --> 00:00:40.906 align:middle
que seguiría funcionando. Sin

00:00:41.386 --> 00:00:46.816 align:middle
embargo, tiene algunos aspectos negativos,
como ser supermágico -es difícil de depurar

00:00:46.816 --> 00:00:50.196 align:middle
si no funciona- y tienes que
hacer algunas cosas raras

00:00:50.196 --> 00:00:53.436 align:middle
para asegurarte de que se ejecuta al
editar la contraseña de un usuario.

00:00:54.216 --> 00:01:00.206 align:middle
Afortunadamente, en API Platform 3 tenemos una nueva
y brillante herramienta que podemos aprovechar.

00:01:00.556 --> 00:01:02.896 align:middle
Se llama procesador de estado.

00:01:03.536 --> 00:01:07.366 align:middle
Y de hecho, ¡nuestra clase User
ya utiliza un procesador de estado!

00:01:08.056 --> 00:01:11.666 align:middle
Busca la guía de actualización
de la API Platform 2 a la 3...

00:01:12.166 --> 00:01:13.926 align:middle
y busca procesador.

00:01:14.806 --> 00:01:15.526 align:middle
Veamos...

00:01:15.916 --> 00:01:16.676 align:middle
allá vamos.

00:01:16.936 --> 00:01:19.736 align:middle
Tiene una sección llamada
proveedores y procesadores.

00:01:20.086 --> 00:01:21.666 align:middle
Hablaremos de los proveedores más adelante.

00:01:22.416 --> 00:01:28.926 align:middle
Según esto, si tienes una clase ApiResource
que es una entidad -como en nuestra aplicación-

00:01:29.456 --> 00:01:36.096 align:middle
, entonces, por ejemplo, tu operación Put ya utiliza
un procesador de estado llamado PersistProcessor

00:01:36.726 --> 00:01:42.296 align:middle
La operación Post también lo utiliza, y
Delete tiene uno llamado RemoveProcessor.

00:01:43.096 --> 00:01:45.136 align:middle
Los procesadores de estado son geniales.

00:01:45.726 --> 00:01:49.796 align:middle
Después de que los datos enviados se
deserialicen en el objeto, nosotros...

00:01:50.016 --> 00:01:51.366 align:middle
¡necesitamos hacer algo!

00:01:51.956 --> 00:01:56.236 align:middle
La mayoría de las veces, ese "algo" es:
guardar el objeto en la base de datos.

00:01:56.726 --> 00:02:00.036 align:middle
¡Y eso es precisamente lo
que hace PersistProcessor!

00:02:00.636 --> 00:02:05.456 align:middle
Sí, ¡nuestros cambios de entidad se guardan
en la base de datos por completo gracias a

00:02:05.456 --> 00:02:07.596 align:middle
ese procesador de estado incorporado!

00:02:08.486 --> 00:02:14.226 align:middle
Así que éste es el plan: vamos a engancharnos al sistema
de procesadores de estado y añadir el nuestro propio.

00:02:15.016 --> 00:02:18.496 align:middle
Primer paso: ejecuta un nuevo comando
desde la API Platform: php ./bin/console

00:02:18.496 --> 00:02:25.346 align:middle
make:state-processor Llamémoslo
UserHashPasswordProcessor. Perfecto.

00:02:27.116 --> 00:02:32.566 align:middle
Gira, entra en src/, abre el nuevo
directorio State/ y echa un vistazo a

00:02:32.566 --> 00:02:37.536 align:middle
UserHashPasswordStateProcessor: Es
deliciosamente sencillo: API Platform

00:02:38.006 --> 00:02:44.426 align:middle
llamará a este método, nos pasará datos, nos
dirá qué operación se está produciendo... y

00:02:44.766 --> 00:02:46.286 align:middle
algunas cosas más. Luego...

00:02:46.816 --> 00:02:49.016 align:middle
hacemos lo que queramos. Enviar

00:02:49.386 --> 00:02:54.966 align:middle
correos electrónicos, guardar cosas en la base de datos,
¡o RickRollar a alguien viendo un screencast! Activar

00:02:55.596 --> 00:02:58.266 align:middle
este procesador es sencillo en teoría.

00:02:58.816 --> 00:03:04.306 align:middle
Podríamos ir a la operación Post, añadir una opción processor y
configurarla con nuestro id de servicio: UserHashPasswordStateProcessor::class.

00:03:04.596 --> 00:03:07.426 align:middle
Desgraciadamente...

00:03:08.026 --> 00:03:09.266 align:middle
si

00:03:09.516 --> 00:03:15.006 align:middle
hiciéramos eso, sustituiría al
PersistProcessor que está utilizando ahora. Y...

00:03:15.346 --> 00:03:19.536 align:middle
no queremos eso: queremos que se
ejecute nuestro nuevo procesador... y

00:03:19.886 --> 00:03:23.256 align:middle
también el existente PersistProcessor. Pero...

00:03:24.016 --> 00:03:27.596 align:middle
cada operación sólo puede
tener un procesador. ¡ No

00:03:28.286 --> 00:03:28.926 align:middle
te preocupes!

00:03:29.156 --> 00:03:31.796 align:middle
Podemos hacerlo decorando
PersistProcessor . La decoración

00:03:32.496 --> 00:03:34.636 align:middle
sigue siempre el mismo patrón. Primero,

00:03:35.186 --> 00:03:40.176 align:middle
añade un constructor que acepte un argumento
con la misma interfaz que nuestra clase: private

00:03:40.526 --> 00:03:48.036 align:middle
ProcessorInterface y lo llamaré $innerProcessor:
Después de añadir un dump() para ver si

00:03:48.036 --> 00:03:52.836 align:middle
funciona, haremos el paso 2: llamar al método de
servicio decor ado: $this->innerProcessor->process()

00:03:53.386 --> 00:04:00.796 align:middle
pasando $data, $operation,
$uriVariables y... sí,

00:04:00.796 --> 00:04:06.436 align:middle
$context: Me encanta: nuestra clase está
preparada para la decoración. Ahora

00:04:07.016 --> 00:04:09.366 align:middle
tenemos que decirle a Symfony
que la utilice. Internamente,

00:04:10.176 --> 00:04:14.316 align:middle
PersistProcessor de API
Platform es un servicio. Vamos a

00:04:14.896 --> 00:04:20.026 align:middle
decirle a Symfony que siempre que algo
necesite ese servicio PersistProcessor, le

00:04:20.256 --> 00:04:23.166 align:middle
pase nuestro servicio en su lugar... pero

00:04:23.686 --> 00:04:28.566 align:middle
también que Symfony nos pase el
PersistProcessor original. Para ello

00:04:29.616 --> 00:04:34.236 align:middle
, añade #[AsDecorator()] y
pásale el id del servicio.

00:04:34.686 --> 00:04:37.266 align:middle
Normalmente puedes encontrarlo
en la documentación, o

00:04:37.596 --> 00:04:41.176 align:middle
puedes utilizar el comando debug:container
para buscarlo. La documentación

00:04:41.756 --> 00:04:46.626 align:middle
dice que es api_platform.doctrine.orm.state.persist_processor:
¡Decoración

00:04:46.706 --> 00:04:50.656 align:middle
hecha!

00:04:51.116 --> 00:04:54.566 align:middle
Todavía no estamos haciendo nada, ¡pero vamos a
ver si llega a nuestro volcado! Ejecuta la prueba:

00:04:55.046 --> 00:04:57.906 align:middle
Y... ¡ahí

00:04:58.356 --> 00:04:59.176 align:middle
está! Sigue siendo

00:04:59.466 --> 00:05:02.896 align:middle
un 500, ¡pero está utilizando
nuestro procesador! Ahora

00:05:03.616 --> 00:05:05.036 align:middle
podemos ponernos a trabajar. Debido a

00:05:05.646 --> 00:05:07.636 align:middle
cómo hicimos la decoración del
servicio, nuestro nuevo procesador

00:05:07.966 --> 00:05:12.276 align:middle
será llamado siempre que se
procese cualquier entidad... ya sea

00:05:12.496 --> 00:05:15.686 align:middle
un User, DragonTreasure o cualquier
otra cosa. Así que, empieza

00:05:16.256 --> 00:05:20.036 align:middle
por comprobar si $data es
un instanceof User... y si

00:05:20.456 --> 00:05:23.096 align:middle
$data->getPlainPassword()... porque si

00:05:23.586 --> 00:05:29.896 align:middle
estamos editando un usuario, y no se envía ningún
password, no hace falta que hagamos nada: Por

00:05:30.656 --> 00:05:32.956 align:middle
cierto, la documentación oficial para decor ar

00:05:32.956 --> 00:05:36.176 align:middle
procesadores de estado es
ligeramente diferente. A

00:05:36.726 --> 00:05:41.566 align:middle
mí me parece más complejo, pero el resultado
final es un procesador que sólo se llama para una

00:05:41.646 --> 00:05:44.066 align:middle
entidad, no para todas. Para hacer hash

00:05:44.956 --> 00:05:48.236 align:middle
con la contraseña, añade un segundo argumento al
constructor: private UserPasswordHasherInterface

00:05:48.826 --> 00:05:55.356 align:middle
llamado $userPasswordHasher: A continuación,
digamos que $data->setPassword()

00:05:55.816 --> 00:05:58.346 align:middle
se establece en
$this->userPasswordHasher->hashPassword()

00:05:58.346 --> 00:06:04.896 align:middle
pasándole el User, que
es $data y la contraseña

00:06:05.256 --> 00:06:08.506 align:middle
simple: $data->getPlainPassword():
Y todo esto

00:06:08.996 --> 00:06:14.496 align:middle
ocurre antes de que llamemos al procesador interno
que guarda realmente el objeto. ¡ Vamos a probar esto

00:06:15.416 --> 00:06:16.236 align:middle
! Ejecuta la prueba

00:06:16.576 --> 00:06:20.596 align:middle
: ¡Victoria! Después de crear

00:06:20.876 --> 00:06:26.436 align:middle
un usuario en nuestra API, podemos iniciar
sesión como ese usuario. Ah, y es algo

00:06:26.986 --> 00:06:32.106 align:middle
sin importancia, pero una vez que tienes una
propiedad plainPassword, dentro de User , hay un

00:06:32.516 --> 00:06:34.736 align:middle
método llamado eraseCredentials().
Descomenta $this->plainPassword

00:06:35.376 --> 00:06:41.646 align:middle
= null: Esto asegura que si
el objeto se serializa en la

00:06:41.646 --> 00:06:45.996 align:middle
sesión, primero se borre la
plainPassword sensible. A continuación:

00:06:46.856 --> 00:06:50.996 align:middle
arreglemos algunos problemas de validación
mediante validationGroups y descubramos

00:06:51.216 --> 00:06:54.606 align:middle
algo especial sobre la operación Patch.
