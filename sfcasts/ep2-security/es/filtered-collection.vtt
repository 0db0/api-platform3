WEBVTT

00:00:01.106 --> 00:00:03.686 align:middle
Oye, ¡hemos creado una API bastante elegante!

00:00:04.156 --> 00:00:09.466 align:middle
Tenemos unos cuantos sub-recursos y datos de
relación incrustados, que se pueden leer y escribir.

00:00:10.046 --> 00:00:11.896 align:middle
Todo esto es estupendo...

00:00:12.136 --> 00:00:17.966 align:middle
pero seguro que aumenta la complejidad de nuestra API,
sobre todo en lo que se refiere a la seguridad. Por

00:00:18.586 --> 00:00:22.106 align:middle
ejemplo, ya no podemos
ver tesoros no publicados

00:00:22.106 --> 00:00:25.806 align:middle
desde las rutas GET
colección o GET individual.

00:00:26.186 --> 00:00:30.406 align:middle
Pero aún podemos ver tesoros
inéditos si obtienes un usuario

00:00:30.496 --> 00:00:33.076 align:middle
y lees su campo dragonTreasures.

00:00:33.686 --> 00:00:36.596 align:middle
Hagamos una prueba rápida
para exponer este problema.

00:00:37.416 --> 00:00:39.006 align:middle
Abre nuestro UserResourceTest.

00:00:39.956 --> 00:00:45.536 align:middle
En la parte inferior, añade una función
pública testUnpublishedTreasuresNotReturned().

00:00:46.696 --> 00:00:51.056 align:middle
Dentro de ella, crea un usuario
con UserFactory::createOne().

00:00:52.086 --> 00:00:57.146 align:middle
A continuación, utiliza DragonTreasureFactory
para crear un tesoro que sea isPublished falso

00:00:58.056 --> 00:01:00.726 align:middle
y tenga su owner establecido en $user...

00:01:01.116 --> 00:01:03.216 align:middle
para que sepamos quién es el propietario.

00:01:03.926 --> 00:01:06.226 align:middle
Para la acción, digamos $this->browser()...

00:01:06.976 --> 00:01:09.476 align:middle
y necesitamos iniciar sesión
para utilizar la ruta ...

00:01:09.786 --> 00:01:12.256 align:middle
pero no nos importa con quién
hemos iniciado sesión...

00:01:12.666 --> 00:01:19.066 align:middle
así que di actingAs() UserFactory::createOne()
para iniciar sesión como otra persona.

00:01:19.686 --> 00:01:25.966 align:middle
Luego ->get() /api/users/
$user->getId() . Termina

00:01:27.286 --> 00:01:33.196 align:middle
con assertJsonMatches() que el
length() de dragonTreasures es cero

00:01:33.916 --> 00:01:39.006 align:middle
-utilizando una función genial length() de
esa sintaxis JMESPath: ¡Vamos a probarlo!

00:01:39.556 --> 00:01:40.236 align:middle
Copia el método...

00:01:40.696 --> 00:01:46.086 align:middle
y ejecútalo con --filter= ese nombre: ¡Vale!

00:01:46.446 --> 00:01:52.026 align:middle
Esperaba que 1 fuera igual a 0 porque
estamos devolviendo el tesoro no publicado...

00:01:52.686 --> 00:01:54.496 align:middle
¡pero no queremos!

00:01:55.326 --> 00:01:59.466 align:middle
Primero... ¿por qué se devuelve
este DragonTreasure inédito?

00:01:59.956 --> 00:02:04.196 align:middle
¿No creamos clases de extensión de
consulta para evitar exactamente esto?

00:02:04.786 --> 00:02:10.096 align:middle
Bueno...., algo importante que hay que entender es que
estas clases de extensión de consulta sólo se utilizan

00:02:10.096 --> 00:02:13.016 align:middle
para la consulta principal en una ruta.

00:02:13.756 --> 00:02:19.936 align:middle
Por ejemplo, si utilizamos el endpoint GET
colección para tesoros, la consulta "principal" es

00:02:19.936 --> 00:02:24.136 align:middle
para esos tesoros y se llama a la
extensión de consulta colección.

00:02:24.686 --> 00:02:29.596 align:middle
Pero cuando hacemos una llamada a un punto final de
usuario -por ejemplo, para obtener un único User - , la

00:02:29.876 --> 00:02:33.906 align:middle
API Platform no consulta ningún tesoro:

00:02:34.316 --> 00:02:37.056 align:middle
está haciendo una consulta
para ese único User. Una

00:02:37.596 --> 00:02:40.836 align:middle
vez que tiene ese User, para
obtener ese campo dragonTreasures,

00:02:41.226 --> 00:02:44.936 align:middle
no hace otra consulta para
esos, al menos no directamente.

00:02:45.456 --> 00:02:51.196 align:middle
En su lugar, si abre la entidad User, la
API Platform -a través del serializador-

00:02:51.506 --> 00:02:54.076 align:middle
simplemente llama a getDragonTreasures().

00:02:54.866 --> 00:02:58.156 align:middle
Así que consulta el User, llama
a ->getDragonTreasures()...

00:02:58.586 --> 00:03:02.936 align:middle
y lo que devuelva se coloca
en el campo dragonTreasures.

00:03:03.566 --> 00:03:06.336 align:middle
Y como esto devuelve todos
los tesoros relacionados,

00:03:06.596 --> 00:03:10.296 align:middle
eso es lo que obtenemos:
incluidos los no publicados.

00:03:11.026 --> 00:03:12.186 align:middle
¿Cómo podemos arreglar esto?

00:03:12.596 --> 00:03:16.456 align:middle
Añadiendo un nuevo método que sólo
devuelva los tesoros publicados.

00:03:17.246 --> 00:03:20.386 align:middle
Digamos public function
getPublishedDragonTreasures() , que devuelve

00:03:20.796 --> 00:03:22.416 align:middle
un Collection.

00:03:23.306 --> 00:03:28.976 align:middle
Dentro, podemos ponernos elegantes: devuelve
$this->dragonTreasures->filter() pasándole

00:03:28.976 --> 00:03:32.156 align:middle
una llamada de retorno con un
argumento DragonTreasure $treasure.

00:03:33.686 --> 00:03:39.616 align:middle
Luego, devuelve $treasure->getIsPublished()
: Es un truco ingenioso para

00:03:39.616 --> 00:03:45.256 align:middle
recorrer todos los tesoros y obtener una nueva
y brillante colección sólo con los publicados.

00:03:45.856 --> 00:03:51.726 align:middle
Nota al margen: un inconveniente de este enfoque
es que si un usuario tiene 100 tesoros...

00:03:52.026 --> 00:03:58.266 align:middle
pero sólo 10 de ellos están publicados,
internamente Doctrine consultará primero los 100...

00:03:58.516 --> 00:04:00.466 align:middle
aunque sólo devolvamos 10.

00:04:01.146 --> 00:04:04.836 align:middle
Si tienes colecciones grandes, esto
puede ser un problema de rendimiento.

00:04:05.526 --> 00:04:10.596 align:middle
En nuestro tutorial de Doctrine, hablamos de
solucionar esto con algo llamado sistema de Criterios.

00:04:11.226 --> 00:04:13.866 align:middle
Pero con ambos enfoques,
el resultado es el mismo:

00:04:14.396 --> 00:04:17.196 align:middle
un método que devuelve un
subconjunto de la colección.

00:04:18.096 --> 00:04:22.166 align:middle
En este punto, el nuevo método funcionará,
pero aún no forma parte de nuestra API.

00:04:23.106 --> 00:04:25.706 align:middle
Desplázate hasta la propiedad dragonTreasures.

00:04:26.486 --> 00:04:29.006 align:middle
Actualmente es legible y
escribible en nuestra API.

00:04:29.886 --> 00:04:39.426 align:middle
Haz que la propiedad sólo sea escribible: A continuación,
abajo en el nuevo método, añade #[Groups('user:read')]

00:04:39.526 --> 00:04:44.296 align:middle
para que forme parte de nuestra API y
#[SerializedName('dragonTreasures')]

00:04:44.556 --> 00:04:48.566 align:middle
para darle el nombre original:
¡redoble de tambores!

00:04:48.756 --> 00:04:52.726 align:middle
Haz la prueba: ¡Explota!

00:04:52.886 --> 00:04:53.346 align:middle
Porque...

00:04:53.346 --> 00:04:54.496 align:middle
Tengo un error de sintaxis.

00:04:55.746 --> 00:04:56.326 align:middle
Prueba de nuevo.

00:04:57.746 --> 00:04:58.966 align:middle
¡Todo verde!

00:04:59.546 --> 00:05:00.766 align:middle
Y... ¡hemos terminado!

00:05:01.306 --> 00:05:02.066 align:middle
¡Lo has conseguido!

00:05:02.586 --> 00:05:06.476 align:middle
Muchas gracias por acompañarme
en este gigantesco, genial y

00:05:06.476 --> 00:05:09.756 align:middle
desafiante viaje hacia la
API Platform y la seguridad.

00:05:10.346 --> 00:05:12.966 align:middle
Algunas partes de este tutorial
han sido bastante complejas...

00:05:13.226 --> 00:05:16.866 align:middle
porque quiero que seas capaz de resolver
problemas de seguridad reales y difíciles.

00:05:17.456 --> 00:05:21.766 align:middle
En el próximo tutorial, vamos a ver
cosas aún más personalizadas y potentes

00:05:21.766 --> 00:05:26.076 align:middle
que puedes hacer con la API Platform
, incluyendo cómo utilizar clases

00:05:26.076 --> 00:05:29.536 align:middle
para recursos API que no son entidades.

00:05:30.256 --> 00:05:34.116 align:middle
Mientras tanto, cuéntanos qué
estás construyendo y, como siempre,

00:05:34.356 --> 00:05:36.096 align:middle
estamos a tu disposición en
la sección de comentarios.

00:05:36.846 --> 00:05:38.426 align:middle
Muy bien amigos, ¡hasta la próxima!
