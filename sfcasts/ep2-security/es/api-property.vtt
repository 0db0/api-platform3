WEBVTT

00:00:01.116 --> 00:00:05.056 align:middle
Controlamos qué campos son legibles y
escribibles mediante grupos de serialización.

00:00:05.256 --> 00:00:08.546 align:middle
Pero, ¿y si tienes un campo
que debe incluirse en la API...

00:00:08.956 --> 00:00:10.946 align:middle
¿pero sólo para determinados usuarios?

00:00:11.726 --> 00:00:15.516 align:middle
Lamentablemente, los grupos no pueden
hacer ese tipo de magia por sí solos.

00:00:15.516 --> 00:00:20.606 align:middle
Por ejemplo, busca el campo $isPublished
y hagamos que forme parte de nuestra API

00:00:20.716 --> 00:00:26.316 align:middle
añadiendo los grupos treasure:read y treasure:write:
Ahora si giramos y probamos las pruebas:

00:00:28.316 --> 00:00:32.646 align:middle
Esto hace que falle una prueba:
testGetCollectionOfTreasures ve

00:00:32.646 --> 00:00:34.906 align:middle
que se devuelve isPublished...

00:00:35.176 --> 00:00:36.786 align:middle
y no se lo espera. Éste es el

00:00:37.576 --> 00:00:44.066 align:middle
plan: colaremos el campo en nuestra API,
pero sólo para los usuarios administradores

00:00:44.216 --> 00:00:46.676 align:middle
o propietarios de este DragonTreasure.

00:00:47.326 --> 00:00:49.646 align:middle
¿Cómo podemos conseguirlo?

00:00:49.646 --> 00:00:50.876 align:middle
Bueno, ¡sorpresa! No

00:00:51.086 --> 00:00:55.186 align:middle
solemos necesitarlo, pero podemos
añadir un atributo ApiProperty

00:00:55.316 --> 00:00:58.446 align:middle
encima de cualquier propiedad
para ayudar a configurarla mejor.

00:00:59.086 --> 00:01:02.066 align:middle
Tiene un montón de cosas,
como una descripción que ayuda

00:01:02.066 --> 00:01:04.746 align:middle
con tu documentación y muchas cosas de borde.

00:01:05.226 --> 00:01:06.996 align:middle
Incluso hay uno llamado readable.

00:01:07.686 --> 00:01:12.166 align:middle
Si dijéramos readable: false: Entonces
los grupos de serialización dirían

00:01:12.166 --> 00:01:14.786 align:middle
que esto debería incluirse en la respuesta...

00:01:15.046 --> 00:01:17.316 align:middle
pero entonces esto anularía eso.

00:01:17.896 --> 00:01:24.056 align:middle
Observa: si probamos las pruebas:
Pasan porque el campo no está.

00:01:24.056 --> 00:01:29.466 align:middle
Para nuestra misión, podemos aprovechar
una opción superguay llamada security.

00:01:29.466 --> 00:01:34.816 align:middle
Ponla en is_granted("ROLE_ADMIN"): ¡Eso es!

00:01:35.356 --> 00:01:41.026 align:middle
Si esta expresión devuelve false,
isPublished no se incluirá en la API:

00:01:41.686 --> 00:01:43.996 align:middle
no será legible ni escribible.

00:01:44.686 --> 00:01:52.726 align:middle
Y cuando ahora ejecutamos las pruebas: Siguen pasando,
lo que significa que no se devuelve isPublished.

00:01:53.686 --> 00:01:57.746 align:middle
Ahora vamos a probar la ruta "feliz"
en la que se devuelve este campo.

00:01:58.326 --> 00:02:00.316 align:middle
Abre DragonTreasureResourceTest.

00:02:01.346 --> 00:02:04.646 align:middle
Aquí está la prueba original:
testGetCollectionOfTreasures().

00:02:05.446 --> 00:02:08.786 align:middle
Somos anónimos, así que
isPublished no se devuelve.

00:02:10.086 --> 00:02:13.976 align:middle
Ahora desplázate hasta
testAdminCanPatchToEditTreasure().

00:02:15.346 --> 00:02:20.586 align:middle
Cuando creemos el DragonTreasure, asegurémonos de
que siempre empieza por isPublished => false:

00:02:22.146 --> 00:02:26.646 align:middle
Luego, aquí abajo,
assertJsonMatches('isPublished',

00:02:26.756 --> 00:02:34.826 align:middle
false) para comprobar que se devuelve el campo:
Copia el nombre de la prueba, gira y añade

00:02:35.016 --> 00:02:38.546 align:middle
--filter para ejecutar sólo esa prueba: Y...

00:02:38.946 --> 00:02:40.306 align:middle
¡pasa!

00:02:40.686 --> 00:02:43.426 align:middle
El campo se devuelve cuando
somos administradores.

00:02:44.256 --> 00:02:46.506 align:middle
¿Y si somos el propietario del tesoro?

00:02:47.216 --> 00:02:48.016 align:middle
Copia la prueba...

00:02:49.866 --> 00:02:54.556 align:middle
cámbiale el nombre a
testOwnerCanSeeIsPublishedField()...

00:02:54.556 --> 00:02:55.976 align:middle
y vamos a modificar algunas cosas.

00:02:56.416 --> 00:03:02.336 align:middle
Cambia el nombre de $admin a $user, simplifícalo
a DragonTreasureFactory::createOne()

00:03:02.826 --> 00:03:09.036 align:middle
y asegúrate de que owner se establece en nuestro nuevo
$user: Podríamos cambiar esto a una petición GET...

00:03:09.216 --> 00:03:10.496 align:middle
pero PATCH está bien.

00:03:10.966 --> 00:03:15.616 align:middle
En cualquiera de las dos situaciones, queremos
asegurarnos de que se devuelve el campo isPublished.

00:03:16.416 --> 00:03:18.316 align:middle
Como aún no hemos implementado esto...

00:03:18.446 --> 00:03:19.726 align:middle
asegurémonos de que falla.

00:03:20.576 --> 00:03:27.176 align:middle
Copia el nombre del método e
inténtalo: ¡Fallo conseguido!

00:03:27.536 --> 00:03:29.466 align:middle
¡Y ya sabemos cómo solucionarlo!

00:03:29.856 --> 00:03:37.966 align:middle
En la opción security, podríamos alinear
la lógica con or object.getOwner() === user.

00:03:38.456 --> 00:03:44.216 align:middle
Pero recuerda: ¡hemos creado el votante para
que no tengamos que hacer locuras como ésa!

00:03:44.746 --> 00:03:53.486 align:middle
En lugar de eso, di is_granted(), EDIT y luego
object: Prueba la prueba ahora: ¡Ya está!

00:03:53.486 --> 00:03:59.206 align:middle
Ah, y no la he utilizado mucho, pero también
existe la opción securityPostDenormalize. Al

00:03:59.786 --> 00:04:04.326 align:middle
igual que con la opción
securityPostDenormalize en cada operación,

00:04:04.626 --> 00:04:09.176 align:middle
ésta se ejecuta después de que los
nuevos datos se deserialicen en el objeto.

00:04:09.786 --> 00:04:13.506 align:middle
Lo interesante es que si la
expresión devuelve false,

00:04:13.846 --> 00:04:17.116 align:middle
en realidad se revierten los datos del objeto.

00:04:17.116 --> 00:04:22.686 align:middle
Por ejemplo, supongamos que la propiedad
isPublished comenzó como false

00:04:23.056 --> 00:04:27.156 align:middle
y luego el usuario envió algo
de JSON para cambiarla a true.

00:04:27.786 --> 00:04:31.306 align:middle
Pero entonces, securityPostDenormalize
devolvió false.

00:04:31.896 --> 00:04:38.386 align:middle
En ese caso, API Platform revertirá la
propiedad isPublished a su valor original:

00:04:38.756 --> 00:04:41.156 align:middle
la cambiará de false a true.

00:04:41.926 --> 00:04:48.456 align:middle
Ah, y por cierto, securityPostDenormalize
no se ejecuta en peticiones a GET:

00:04:48.456 --> 00:04:50.966 align:middle
sólo ocurre cuando se están
deserializando los datos.

00:04:50.966 --> 00:04:55.296 align:middle
Así que asegúrate de poner tu lógica
de seguridad principal en security

00:04:55.716 --> 00:04:59.186 align:middle
y sólo utiliza securityPostDenormalize
si lo necesitas.

00:05:00.356 --> 00:05:04.486 align:middle
Lo siguiente en nuestra lista de tareas: vamos
a nivelar nuestras operaciones de usuario

00:05:04.486 --> 00:05:07.846 align:middle
para hacer un hash de la contraseña
antes de guardarla en la base de datos.

00:05:08.326 --> 00:05:13.106 align:middle
Necesitaremos una nueva propiedad de
contraseña simple no persistente para hacerlo.
