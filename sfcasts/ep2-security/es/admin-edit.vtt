WEBVTT

00:00:01.066 --> 00:00:04.746 align:middle
Hemos configurado las cosas para que sólo
el propietario de un tesoro pueda editarlo.

00:00:05.426 --> 00:00:09.866 align:middle
Ahora, ha llegado un nuevo
requisito desde las alturas:

00:00:10.276 --> 00:00:13.606 align:middle
los usuarios administradores deben
poder editar cualquier tesoro.

00:00:14.226 --> 00:00:16.906 align:middle
Eso significa que un usuario
que tenga ROLE_ADMIN.

00:00:17.356 --> 00:00:19.196 align:middle
¡A la prueba-móvil!

00:00:19.616 --> 00:00:23.086 align:middle
Añade un public function
testAdminCanPatchToEditTreasure() . A

00:00:24.986 --> 00:00:30.886 align:middle
continuación, crea un usuario admin con
UserFactory::createOne() pasando los roles

00:00:30.886 --> 00:00:34.296 align:middle
a ROLE_ADMIN: Eso funcionará bien.

00:00:34.756 --> 00:00:40.676 align:middle
Pero si necesitamos crear muchos usuarios admin en nuestras
pruebas, podemos añadir un acceso directo a Foundry.

00:00:41.386 --> 00:00:42.566 align:middle
Abre UserFactory.

00:00:43.056 --> 00:00:45.646 align:middle
Vamos a crear algo llamado método "estado".

00:00:46.236 --> 00:00:50.706 align:middle
En cualquier lugar de su interior, añade una
función pública llamada, qué tal withRoles()

00:00:51.116 --> 00:00:55.056 align:middle
que tenga un argumento array $roles
y devuelva self , lo que hará que

00:00:55.056 --> 00:00:57.446 align:middle
esto sea más cómodo cuando lo utilicemos.

00:00:58.426 --> 00:01:03.016 align:middle
Entonces return
$this->addState(['roles' => $roles]):

00:01:04.716 --> 00:01:10.436 align:middle
Lo que pasemos a addState() se convierte en parte de
los datos que se utilizarán para hacer este usuario.

00:01:11.216 --> 00:01:16.196 align:middle
Para utilizar el método de estado, el
código cambia a UserFactory::new().

00:01:16.196 --> 00:01:22.566 align:middle
En lugar de crear un objeto User, se
instanciará un nuevo UserFactory...

00:01:22.956 --> 00:01:28.506 align:middle
y entonces podemos llamar a
withRoles() y pasar a ROLE_ADMIN: Así,

00:01:28.506 --> 00:01:31.746 align:middle
estamos "elaborando" el aspecto
que queremos que tenga el usuario.

00:01:32.326 --> 00:01:37.876 align:middle
Cuando hayamos terminado, llamamos a create():
createOne() es un método abreviado estático.

00:01:38.316 --> 00:01:41.446 align:middle
Pero como tenemos una instancia
de la fábrica, utiliza create().

00:01:42.186 --> 00:01:43.686 align:middle
Pero podemos ir aún más lejos.

00:01:44.396 --> 00:01:50.476 align:middle
De vuelta en UserFactory, añade otro método
de estado llamado asAdmin() que devuelva self.

00:01:50.476 --> 00:01:56.686 align:middle
Dentro devuelve
$this->withRoles(['ROLE_ADMIN']): Gracias a eso,

00:01:57.086 --> 00:02:04.596 align:middle
podemos simplificar a
UserFactory::new()->asAdmin()->create(): ¡Bien!

00:02:05.046 --> 00:02:06.736 align:middle
Ahora pongamos en marcha esta prueba.

00:02:07.316 --> 00:02:11.496 align:middle
Crea un nuevo $treasure fijado en
DragonTreasureFactory::createOne():

00:02:12.126 --> 00:02:15.826 align:middle
Como no estamos pasando un
owner, esto creará un nuevo User

00:02:15.826 --> 00:02:19.006 align:middle
en segundo plano y lo utilizará como owner.

00:02:19.586 --> 00:02:23.436 align:middle
Esto significa que nuestro usuario
administrador no será el propietario.

00:02:24.386 --> 00:02:32.266 align:middle
Ahora, $this->browser()->actingAs($adminUser)
luego ->patch() a /api/treasures/,

00:02:32.266 --> 00:02:40.486 align:middle
$treasure->getId(), enviando json
para actualizar value al mismo 12345.

00:02:42.296 --> 00:02:49.996 align:middle
->assertStatus(200) y
assertJsonMatches(), value, 12345: ¡Genial!

00:02:50.466 --> 00:02:51.526 align:middle
Copia el nombre del método.

00:02:52.046 --> 00:03:00.506 align:middle
Vamos a probarlo: symfony php bin/phpunit
--filter=testAdminCanPatchToEditTreasure Y...

00:03:00.896 --> 00:03:04.246 align:middle
¡vale! Aún no lo hemos
implementado, así que falla.

00:03:04.246 --> 00:03:08.106 align:middle
Entonces, ¿cómo permitimos que los
administradores editen cualquier tesoro?

00:03:08.796 --> 00:03:14.766 align:middle
Bueno, al principio es relativamente fácil porque tenemos
el control total a través de la expresión security.

00:03:15.316 --> 00:03:20.126 align:middle
Así que podemos añadir algo como
if is_granted("ROLE_ADMIN") OR

00:03:20.586 --> 00:03:25.886 align:middle
y luego poner paréntesis alrededor del otro
caso de uso: ¡Asegurémonos de que funciona!

00:03:27.886 --> 00:03:28.966 align:middle
¡Un error 500!

00:03:29.386 --> 00:03:30.536 align:middle
Veamos qué está pasando.

00:03:30.886 --> 00:03:31.936 align:middle
Haz clic para abrir esto.

00:03:33.156 --> 00:03:36.326 align:middle
Token "nombre" inesperado en la posición 26.

00:03:37.176 --> 00:03:39.626 align:middle
Así que... eso ha sido un accidente.

00:03:40.116 --> 00:03:42.336 align:middle
Cambia OR por or.

00:03:43.336 --> 00:03:45.446 align:middle
Y... mueve también esta nueva lógica

00:03:45.446 --> 00:03:52.606 align:middle
a securityPostDenormalize: Luego vuelve
a intentar la prueba: ¡Lo tengo!

00:03:53.186 --> 00:03:58.826 align:middle
Pero mi metedura de pata saca a relucir un gran punto: la
expresión security se está volviendo demasiado compleja.

00:03:59.296 --> 00:04:02.446 align:middle
Es tan legible como un script
PERL de una sola línea...

00:04:02.856 --> 00:04:06.246 align:middle
y no queremos cometer errores
cuando se trata de seguridad.

00:04:06.246 --> 00:04:10.006 align:middle
Así que, a continuación, centralicemos
esta lógica con un votante.
