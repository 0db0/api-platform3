New security goal. I want to allow only the owner of a treasure to edit it. Right now you're allowed to edit a treasure as long as you have this role, which means you can edit anyone's treasure. Not cool. So let's write a test for this. At the bottom I'll say `public function testPatchToUpdateTreasure`. And we'll kind of start our normal way here. We'll say `$user = UserFactory::createOne()` and then `$browser`, this arrow `$browser`, and then we'll say `actingAs($user)`. I'm going to use this for authentication for most of our tests now. It's very easy. And then I'll use the `patch` method for `/api/treasures/` and then actually we're going to need a `treasure` here to edit. So let's also create one up here. `$treasure = DragonTreasureFactory::createOne()`. And for this test, we want to make sure that the `owner` is definitely this user. So we're going to test that. If we go and try to edit that `treasure`, a `treasure` that I own, `$treasure->getId()`. We're going to `assert` that that is allowed. Now let's pass some data here. Let's just change one field. So we'll send some JSON and how about let's just change the `value` to 1, 2, 3, 4, 5. Perfect. So we can `assert` `statusCode` is 200 and we can `assert` that the JSON matches `value` 1, 2, 3, 4, 5. Excellent test. Now this should be allowed because we are the `owner`. So let me copy that method name or run over and do symphony `php bin/phpunit --filter` equals our new method name and no surprises it passes. So let's try the other case. Let's log in as someone else and try to make a change. So I'm going to copy this entire `$browser` section here. I could create another test map if I wanted to, but this will work really well because right before it, we can create a `$user2 = UserFactory::createOne()`. So any other user we don't care. And we're going to log in as that user and then try to edit the `treasure` that's owned by someone else. We'll just change the `value` to 6, 7, 8, 9. In this case, this should not be allowed. So it should be a 4 0 3 `statusCode`. When we try to test now, it fails. It is being allowed. We're getting status code 200 instead of the 4 0 3 we expected. So how can we do this? Well, over in `DragonTreasure`, no surprise. It's all going to be about this `security` attribute. Now, one thing that gets tricky here with `Put` and `Patch` is that you can, both of these are used to edit users. So if you're going to have both of them, you need to be aware of keeping the `security` in sync. I'm actually going to remove `Put` so I can just focus on `Patch`. Now this `security` thing here is an expression so you can actually get a little fancy here. We can say you have to have is granted role `TREASURE_EDIT` and object that `owner` needs to equal user. So inside of this expression, we're given a couple of variables. One of the variables is `user`, which is the current user object. Another very important variable in here is `object`, which is going to be the current object. So the `DragonTreasure` object. So we're saying access should be allowed if `DragonTreasure`s `owner` is equal to the currently authenticated `user`. And now when we try it, Oh, it actually doesn't pass 500. This is where this log comes in really handy because notice I didn't dump what the actual failure was. If I open up this file, we can see it right here. And if this is hard to read, you can do view page source and beautiful. All right. It says `Cannot access private property App\Entity\DragonTreasure::$owner`. And it's coming from Symfony's `ExpressionLanguage`. Ah, I know what I did wrong. This is the `ExpressionLanguage`. It's not twig. So you can't do fancy things like dot `owner`. If because `owner` is a property, you actually need to call the public method. Now our test works. Awesome. So I'm gonna get trickier here. I'm going to copy this test and watch this. We're going to log in as our `user` and edit our own `treasure`, right? All good. But this time I'm going to try to change the `owner` to someone else. `User` to `arrow` get `ID`. Now maybe this is something you allow. Maybe you say, Hey, if you can edit a `DragonTreasure`, if you want to, you can assign it a different `owner`, but let's pretend that's not what we want. So I'm going to keep the `assertStatus` for three. This is going to show us an important thing about security when we try to test it fails, it actually does allow this. So spin back over and look at `DragonTreasure`. I want to talk about the security key. Security is run before the new data is put onto our object. So in other words, by the time this `object` here is going to be the `DragonTreasure` object from the database, but before any of the new JSON is applied to it. So it's checking that the current `owner` is equal to the currently logged in user, which is actually the main case that we want to protect. Sometimes you might also want to run security after the new data has been put onto the `object`. If you have that use case, you can pass something here called `securityPostDenormalize`. Remember denormalize is the word for, denormalize means it's the process of taking the data and putting it onto the `object`. So in this case, security will still run. So it's still going to do the check for to make sure we have that role. It's still going to make sure the original `owner` is the user. And now we can also say inside of here, `object.getOwner()` equals user. Now that looks identical to what we had before, but in this case, `object` is going to be the `DragonTreasure` with the new data. So we're checking that the new `owner` is also equal to the currently logged in user. By the way, if you need to, for some reason, there is also a `previous_object` variable in here. The `previous_object` here is equal to the `object` before serialization. So it's actually the same as `object` up in the security attribute, the security option, but we don't need that. Now and run the test that passes. So I do want to kind of clarify a way of thinking here. There are kind of two different, these two security checks are slightly different. The first security check is trying to determine whether or not we can perform this operation at all. Like is the current user allowed to make a `PATCH` request? And that depends on the current user and the current `object` in the database, how the current `object` in the database looks. This second check here is saying okay, now that I am allowed to make a `PATCH` request in general, am I allowed to make this change to the data? And this depends on the currently logged in user and the new version of the data. I'm bringing this up because for me, if you're trying to figure out whether an operation is at all allowed, regardless of what data is being sent, that is the job for security. And this is exactly how I would implement that. However, if you determine that the user is allowed to use an operation, but then you're trying to figure out whether or not they're allowed to make a certain change to the data, like are they allowed to change the `owner` or not? This for me is really something that's better handled in your validation layer. So I'm going to keep this in the security layer right now, but later we're going to talk about custom validation. And we're actually going to move this check into validation. And I'll kind of make this point about the two different types of security again there later. All right, next. Our security attribute is getting a little bit complex, which I don't love. So let's learn how we can clean this up and centralize things with a voter.