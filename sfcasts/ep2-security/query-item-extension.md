# Query Item Extension

Coming soon...

We no longer return unpublished treasures from the treasure collection endpoint, but we are still allowing them to be returned from the get one endpoint. That's because these query collection extension interface classes, this is only called when we are fetching a collection of items, not when we're selecting a single item. So to prove this, let's go into our test class. I'm gonna duplicate my get collection test. Let's paste that. Call it test get one unpublished Treasure, 4 0 4 s. In here, we're just gonna create the one dragon treasure that is unpublished and they'll make you get requests to API slash treasures slash and then Dragon Treasure. And then, oh, I need to set a dragon Treasure variable. Perfect. Now down here we'll use Dragon Treasure Arrow. Get id. This is pretty easy. We're just gonna assert that status here is 4 0 4 and I don't need any of these assertions down there or this JSON variable. Very simple test. All right, let's copy that method name. Y'all know the drill out.

Run our test for, just run just that test. And yep, it is currently returning a 200 status code. All right, so time to fix that. How? Well, you may have guessed just how there is, just like how you can create a query collection extension interface. There is also a query item extension interface that's used when we're querying for just one item. You can create a totally separate class for this, but you can also combine it. So we can add a second interface here for query item extension interface. And then down at the bottom you can go to code Generate or command N on a Mac and create the one we need, which is applied to item. And you can see it's almost identical to the other method. It does the same thing, it's just used on different endpoints. And so pretty much like all of this logic here, we're gonna need that again. So I'm gonna copy that and then you can go to the refactor menu and say Refactor this or Control T and A Mac. And I'm gonna extract this to a method and we'll call it ADD is published where. Awesome. So down here

We have this new function, which adds that query. And actually, you know what, I should have also added this little if statement inside of there. That's gonna be handy as well. So let me move that part down as well, which means we'll need the string resource class as an argument. Excellent. And then we'll pass resource class up here as well. Perfect. So really done here in Applied item, we can do the exact same thing. We're finding the exact same query. So now if we try to fetch a single item that is unpublished, it shouldn't be returned by that query. And sure enough, when we spin over and run the test, it passes. So we've just made a bunch of changes to our important changes to our code. So let's run all of our tests and uhoh, we've got three failures all coming from Dragon Treasure Resource. So the problem is that in a lot of cases when we are creating treasures, if we search for a Dragon Treasure Factory, we weren't explicit about whether we wanted a published or unpublished one. So we might get a published one, we might get an unpublished one. And this happens because inside Dragon Treasure Factory or is published as currently returning a

Random true or false. So to fix this in our test, we could always be explicit. We could say, look, I'm, I want this is published true in all these cases. Or what I'm gonna do is be a little lazier. I'm gonna say, Hey, by the default in Dragon Treasure Factory, let's set these to is is published. True. That's really the default mode. If I'm creating a dragon treasure, I probably want it to be, uh, published now to make our fixture data a little bit better. And app fixtures. When we create our 40 dragon treasures,

We can override the is published and kind of manually do a little bit of randomness here. So I'll say if we have a random number from zero to 10 and it's greater than three, then we will be published. So this will publish most dragon treasures, believe us with a few unpublished dragon treasures to make our data more realistic. That should fix most of our tests. And Dragon Resource test. There were, there's also a couple of spots if we search for unpublished where when we were testing that an admin can patch to edit a treasure, we created an unpublished dragon treasure just so we could assert that that was, that wasn't the response and it was false. Um, I'm actually gonna change this now to true so that this creates, creates a published treasure. And there's one other spot down here where I will also set that to true. We didn't intend for those to be unpublished. So when we're on the test now they're happy though we do still have one problem. If you find the first patch test that we have here we are creating a published dragon treasure, and then we are updating it and it works just fine. Cool, let's copy this entire test. And really, I just need that first part of the test. I'm gonna delete this bottom part here.

Awesome. And I'll call it TE test patch Unpublished works. So think about it. If we have a dragon treasure, and it is,

This is the first

Is published false. That shouldn't create any problems. This is my treasure. I created it, I created it unpublished, and now I'm just trying to modify some data on it, right? So it shouldn't cause any problems. We want this to work. So when we go over and try it, unfortunately we get a 4 0 4. So this is kind of a little gotcha you need to be aware of when you create a query collection extension interface that's only used on this one collection endpoint. But when you create an item query item extension interface that's used when we fetch a single treasure, but it's also used for delete patch and put, and that was, so when an owner tries to patch their own dragon treasure, thanks to our extension, it can't be found. So there are two solutions for this. The first are that the apply to item is passed the operation. So you can actually use this to figure out as to say get collect, is it, say get request or a patch request or a delete request. And if you wanted to, you could apply this filter to only the get request. And this might make sense because if you're able to edit or edit or delete a treasure, that means you have already passed a security check to do it. So we don't necessarily need to lock it down via the query extension.

The other solution is that inside of our extension class, we can inject the security service to and see who's logged in. And we actually changed the query down here to allow owners to see all treasures. The cool thing about this solution is it's also gonna allow unpublished treasures to be returned from the collection endpoint if the current user is the owner of that treasure. So that's the solution I wanna do. It's a little trickier. So let's add a public function underscore underscore construct. We will auto wire our favorite security service. Perfect. And then down here, we just gotta get a little trickier here. So first thing I'm gonna say is this Arrow user equals this aero security arrow get user. And then if we have a user, we're gonna modify that query builder in a similar but slightly different way. So it's gonna be query builder and where, oh, actually let me also bring the root alias up above my if statement anyways, we have where the item is published or where percent S dot owner equals call owner. And I'll need to pass in one more root alias for this. And then we can say set parameter

Owner set to the current user. And then I'll put in Alice, if there is no user, we're actually just gonna use the original query here Easy. And then down here, we're gonna need the is published parameter in both cases. So we can kind of just finish with aero set Parameter is published. True. All right, I think I like that. Let's try it. Run that test and it passes. So we've fixed and in fact, all of our test passes. All right, final topic. We know that when we fetch a user object, we return its Dragon treasures. Does that collection also include unpublished treasures? The answer is, yep. Let's talk about why next and how to fix it.

